waterTilesRange = 4;
smallPause = 180;
middlePause = 400;
moveItemPause = 600;
colorTrashbag =    '0x0495'; 
masterKeyType = '0x176B';
bankCrystal = 0x42a30987
bankBag = '0x46775617';
pankeyGraphic = '0x09D7';
fullPanGraph = '0x9D8';
extractMiBs = true;
bottleType = '0x99F';
treasureKeyType = '0x14EE';
treasureKeyColor = '0x0745';
dressName = 'panning';

String.prototype.format = function ()
{
    var formatted = this;
    for (var i = 0; i < arguments.length; i++)
    {
        var regexp = new RegExp('\\{' + i + '\\}', 'gi');
        formatted = formatted.replace(regexp, arguments[i]);
    }
    return formatted;
};


function resetRunebook()
{
    Orion.RemoveObject("LargeSpotBook");
    Orion.RemoveObject("cleanRune");
}


function checkRunebook()
{
    var runebook = Orion.GetSerial('LargeSpotBook');
    var cleanRune = Orion.FindType('0x1f14', 'any', 'backpack', 'fast');

    if (!Orion.FindObject(runebook))
    {
        Orion.CharPrint(self, 0x0021,
            "Please target a Runebook with empty spots to begin..")
        Orion.WaitForAddObject("LargeSpotBook");
    }

    if (!Orion.FindObject(cleanRune))
    {
        Orion.Print(
            "No rune found in you backpack. Place a rune in you backpack and try again."
        );
        throw false;
    }

}

function validateRunebook(runebookSerial)
{

     if (! runebookSerial) {
	     runebookSerial = Orion.GetSerial("LargeSpotBook");
     }

    Orion.UseObject(runebookSerial);
    Orion.Wait(middlePause);

    return true;
}

function emptyGoldpan()
{
    Orion.ClearJournal();
    Orion.UseType('0x09D8', '0x0000');
    Orion.Wait(moveItemPause);
    return true;
}

function checkGoldpanContents()
{

    if (Orion.InJournal('large gold', 'sys'))
    {
        Orion.ClearJournal('large gold', 'sys');
        return 'large';
    }
    if (Orion.InJournal('small gold', 'sys'))
    {
        Orion.ClearJournal('small gold', 'sys');
        return 'small';
    }
    if (Orion.InJournal('medium gold', 'sys'))
    {
        Orion.ClearJournal('medium gold', 'sys');
        return 'medium';
    }
    return false;
}

function checkGoldpan()
{

    if (Orion.FindType(pankeyGraphic, '0x0000').length > 0)
    {
        return true;
    }
    else if (Orion.FindType('0x09D8', '0x0000').length > 0)
    {
        return emptyGoldpan();
    }
    else
    {
        return getGoldpan();
    }

}

function processGoldpan()
{
    checkGoldpan();
    return checkGoldpanContents();

}

function findGoldPanKey()
{
    var pankey = Orion.FindType(pankeyGraphic, ('0x7C8|0x7C7'), "backpack")[
        0]; //0x7C8 is 3 Finger Jack Gold Pan and 0x7C7 is the regular one

    if (!Orion.FindObject(pankey))
    {
        Orion.CharPrint('self', 82,
            "**** cant find a goldpan storage in your backpack ****");
        Orion.Wait(smallPause);
        return false;
    }
    return pankey;
}

function getGoldpan()
{
    pankey = findGoldPanKey();

    Orion.UseObject(pankey);
    Orion.WaitGump(Orion.CreateGumpHook(4));
    Orion.Wait(middlePause);
    Orion.WaitGump(Orion.CreateGumpHook(0));
    Orion.Wait(middlePause);

}

function fillGoldKey()
{
    var pankey = findGoldPanKey();
    if (pankey)
    {
Orion.RequestContextMenu('0x006F577F');
Orion.WaitContextMenuID("0x006F577F", 2);
Orion.WaitForGump();

Orion.GetLastGump().Close();
        Orion.CancelContextMenu();
        Orion.RequestContextMenu(pankey);
        Orion.Wait(middlePause);
        Orion.WaitContextMenu(pankey, 2)
        Orion.Wait(middlePause);
        Orion.WaitGump(Orion.CreateGumpHook(0));
        return true;
    }
    else
    {
        Orion.CharPrint('self', 82,
            "**** cant find a goldpan storage found ****");
        Orion.Wait(smallPause);
        return false;
    }

}

function trashLoot()
{
    var trashbag = Orion.FindType('0x09B2', '0x0495', 'backpack', 'fast');

    if (trashbag)
    {
        Orion.Print("Trashing " + Orion.Count('0x170f|0x170b|0x1711|0x2307',
                '0x0000', 'backpack', 'item', false) +
            " items. Please review your trashbag.");
        while (Orion.Count('0x170f|0x170b|0x1711|0x2307', '0x0000', 'backpack',
                'item', false) > 0)
        {
            Orion.MoveItemType('0x170f|0x170b|0x1711|0x2307', '0x0000',
                'backpack', 1, trashbag);
            Orion.Wait(800);
        }
        Orion.OpenContainer(trashbag);
        if (Orion.Count(masterKeyType, 'any', 'backpack'))
        {
            Orion.Say("[ffp");
            Orion.Wait(middlePause);
        }
        return true;
    }
    else
    {
        Orion.CharPrint("self", 82,
            "*** cant find a trash bag, please check it ***");
        Orion.Wait(smallPause);
        return false;
    }

}

function clearMiBs()
{

    if (extractMiBs)
    {
        if (Orion.FindType(treasureKeyType, treasureKeyColor).length > 0)
        {
        		treasureKey = Orion.FindType(treasureKeyType, treasureKeyColor, 'backpack', 'fast');
            Orion.FindType(bottleType, '0x0000')
                .forEach(function (bottle)
                {
                    Orion.UseObject(bottle);
                    Orion.Wait(middlePause);
                });
                Orion.CancelContextMenu();
                 Orion.RequestContextMenu(treasureKey);
                 Orion.Wait(middlePause);
 					 Orion.WaitContextMenu(treasureKey, 2);
                 Orion.Wait(middlePause);
                 Orion.WaitGump(Orion.CreateGumpHook(0));
            return true;
        }
        else
        {
            Orion.CharPrint('self', 82,
                "*** cant find a treasure key, please check it ***");
            Orion.Wait(smallPause);
            return false;
        }
    }
    else
    {
        if (Orion.FindObject(bankCrystal, 'any', 'backpack'))
        {
            Orion.UseObject(bankCrystal);
            Orion.Wait(middlePause);
            var bottles = Orion.FindType(bottleType);
            bottles.forEach(function (item, index)
            {
                Orion.MoveItem(item, bankBag);
                Orion.Wait(middlePause);
            });
            return true;
        }
        else
        {
            Orion.CharPrint('self', 82,
                "*** cant find a bank crystal, please check it ***")
            Orion.Wait(smallPause)
            return false;
        }
    }
}

function checkPole(dressName)
{

    while (Orion.SkillValue('fishing', 'base') < 2000)
    {
        Orion.Dress(dressName);
        Orion.Wait(middlePause);
    }
    Orion.Wait(middlePause);
}

function panTile(X, Y, Z)
{
    worldSave();
    checkGoldpan();
    checkPole(dressName);

    Orion.Wait(middlePause);
    runebookGump = getRunebookGump();

    Orion.Wait(middlePause);

    Orion.UseType(pankeyGraphic, '0x0000');
	Orion.Wait(middlePause);

    Orion.AddFakeMapObject(X.toString() + Y.toString()+Math.abs(Z).toString(), "0x09D8", '999', X, Y, Z);
    Orion.TargetTile('water', X, Y, Z);
    Orion.Wait(middlePause);

}

function worldSave()
{
    if (Orion.InJournal('The world is saving, please wait.', 'system'))
    {
        Orion.CharPrint('self', 82, 'Pausing for world save');
        Orion.Wait(250);
        if (Orion.WaitJournal('World save complete.', 0, 60000, 'system'))
        {
            HeadMsg('Continuing', 'self', 82)
            Orion.Wait(250);
        }
        Orion.ClearJournal();
    }
    return true;
}

function handlePanResult(X, Y, Z)
{
    Orion.ClearJournal();
    panTile(X, Y, Z);
    Orion.Wait(middlePause);

    if (Orion.InJournal("Target cannot", "system"))
    {
        Orion.ClearJournal();
        return false;
    }
    if (Orion.InJournal("to be closer", "system"))
    {
        Orion.ClearJournal()
        return false;
    }
    if (Orion.InJournal("pan for gold there", "system"))
    {
        Orion.ClearJournal();
        return false;
    }
    if (Orion.InJournal("seem to be any", "system"))
    {
        Orion.ClearJournal();
        return false;
    }
    Orion.Wait(middlePause);
    Orion.Wait(10000);
    //    checkSize = checkGoldpan();
    checkSize = processGoldpan();
    Orion.Wait(middlePause);
    if (typeof checkSize == 'string')
    {
        if (checkSize == 'large')
            graph = '0x0C74';
        if (checkSize == 'small')
            graph = '0x172A';
        if (checkSize == 'medium')
            graph = '0x1727';
        Orion.AddFakeMapObject(X.toString() + Y.toString()+Math.abs(Z).toString(), graph, '2997', X, Y, Z);
        return {
            size: checkSize,
            tile: [X, Y, Z]
        };
    }
    if (Orion.InJournal("around until your pan is full", "system") ||
        Orion.InJournal("fail to find any nuggets", "system"))
    {
        Orion.ClearJournal();
        return {
            size: undefined,
            tile: [X, Y, Z]
        };
    }
    if (Orion.InJournal("seem to be any", "system"))
    {
        Orion.ClearJournal();
        return {
            size: undefined,
            tile: [X, Y, Z]
        };
    }
return false;
}

function IsReachable(tile, _range)
{
    var result = Orion.GetTilesInRect('land', (tile.X() - _range), (tile.Y() -
            _range), 0, (tile.X() + _range), (tile.Y() + _range), 255)
        .length;
    //Orion.GetTilesInRect('tileFlags', startX, startY, endX, endY);
    return result >= 1 && result < 30;
}
var fishedWater = [];

function GetWaterTiles(_range)
{

	if (!_range)
	_range = 4;

    Orion.Wait(600);

    var waterTiles = Orion.GetTilesInRect('water', (Player.X() - _range), (
            Player.Y() - _range), (Player.X() + _range), (Player.Y() +
            _range))
        .concat(
            Orion.GetTilesInRect('land', (Player.X() - _range), (Player.Y() -
                _range), (Player.X() + _range), (Player.Y() + _range))
        )
        .filter(function (tile)
        {
            return tile.Graphic() == '0x00A8' ||
                tile.Graphic() == '0x00A9' ||
                tile.Graphic() == '0x00AA' ||
                tile.Graphic() == '0x00AB' ||
                tile.Graphic() == '0x0136' ||
                tile.Graphic() == '0x0137' ||
                tile.Graphic() == '0x1797' ||
                tile.Graphic() == '0x1798' ||
                tile.Graphic() == '0x1799' ||
                tile.Graphic() == '0x179A' ||
                tile.Graphic() == '0x179B' ||
                tile.Graphic() == '0x179C'

        })
        //        .filter(function (tile) {
        //           return (IsReachable(tile, 5)) && (tile.X() - 1) % 8 != 0 && (
        //                tile.Y() - 2) % 8 != 0
        //       })

        //        .filter(function (tile) {
        //            return fishedWater.map(
        //                    function (e) {
        //                        return e.X();
        //                    })
        //                .indexOf(parseInt((tile.X() / 8))) &&
        //                fishedWater.map(
        //                    function (e) {
        //                        return e.Y();
        //                   })
        //              .indexOf(parseInt((tile.Y() / 8)));
        //
        //        })

        .sort(function (t1, t2)
        {
            return Orion.GetDistance(t1.X(), t1.Y()) - Orion.GetDistance(t2
                .X(), t2.Y())
        });

    waterTiles.forEach(function (water)
    {
        Orion.AddFakeMapObject(water.X()
            .toString() + water.Y()
            .toString() + Math.abs(water.Z()).toString(), "0x1828", "", water.X(), water.Y(), water
            .Z());
    });
    return waterTiles;
}


function getNuggetsBookName(runebook)
{
    runebookObj = Orion.FindObject(runebook);
    props = runebookObj.Properties().split("\n");
    for (var i = 0; i < props.length; i++)
    {
        var prop = props[
            i
        ]; //extract the single line, in your snipet you were trying to print the whole array
        if (Orion.Contains(prop, 'Large Nuggets'))
        {
            return prop;
        }
    }

    return false;
}

function readRunebookPositions(runebook)
{

	 if (! runebook){
	    runebook = Orion.GetSerial('LargeSpotBook');
    }
    Orion.UseObject(runebook);
    Orion.Wait(150);

    Orion.WaitForGump(middlePause);

    positions = []

    runebookgump = getRunebookGump();

    for (i = 0; i <= runebookgump.TextList().length; i++)
    {
        splittedText = runebookgump.Text(i).split(",");
        if (splittedText.length >= 3)
        {
            positionobj = {
                'X': splittedText[0],
                'Y': splittedText[1],
                'Z': splittedText[2],
            }
            positions.push(positionobj);
        }

    }

    return positions;
}


function checkIfTileIsMarked(tile)
{
    positions = readRunebookPositions();

    var i = 0;
    for (i = 0; i < positions.length; i++)
    {

        if (
            String(tile.X()) == String(positions[i].X) &&
            String(tile.Y()) == String(positions[i].Y) &&
            String(tile.Z()) == String(positions[i].Z)
        )
        {
            return i;
        }

    }

    return false;

}

function getRunebookGump()
{
var runebookgump;
    for (var i = 0; i < Orion.GumpCount(); i++)
    {
        runebookgump = Orion.GetGump(i);
        if (runebookgump != null && runebookgump.ID() == '0x554B87F3')
        {
            break;
        }
    }

    return runebookgump;
}

function markRune(position_text)
{
    worldSave();
    var cleanRune = Orion.FindType('0x1f14', 'any', 'backpack', 'fast');
    var runebook = Orion.GetSerial('LargeSpotBook');

    runebookgump = getRunebookGump();
    if (runebookgump)
	    runebookgump.Close();
    
    Orion.Cast("Mark");
    Orion.WaitForTarget(5000);
    Orion.Wait(middlePause);
    if (cleanRune)
    {
        Orion.CharPrint(cleanRune, 1990, ".");
        Orion.TargetObject(cleanRune);
        Orion.Wait(middlePause);
        Orion.UseObject(cleanRune);
        Orion.WaitForPrompt(2000);
        Orion.SendPrompt(position_text)
        Orion.Wait(600)
        Orion.MoveItem(cleanRune, 1, runebook)
        Orion.Wait(600)
        return true;
    }
    else
    {
        Orion.Print(
            "No rune found in you backpack. Place a rune in you backpack and try again.",
            1990
        );
    }
}

function PanForGold_SearchNewSpot(waterTilesRange)
{
    Orion.Exec('CheckAntiMacro', true);

    checkRunebook();
    if (! validateRunebook()) {
        Orion.Print(
            "This book has no Panning spots left to mark. Please choose another book."
        );
        Orion.RemoveObject('LargeSpotBook');
        return false;
	}

    waterTiles = GetWaterTiles(waterTilesRange);
    for (var i = 0; i < waterTiles.length; i++)
    {
        worldSave();
        Orion.AddFakeMapObject(waterTiles[i].X()
            .toString() + waterTiles[i].Y()
            .toString(), '0x181A', '0x7', waterTiles[i].X(), waterTiles[i]
            .Y(), waterTiles[i]
            .Z());
        while (true)
        {
            panResult = handlePanResult(waterTiles[i].X(), waterTiles[i].Y(), waterTiles[i].Z() );

            if (typeof panResult == "object")
            {

                Orion.Print("size: " + panResult.size);

                if (panResult.size == "large")
                {
                    check_marked = checkIfTileIsMarked(waterTiles[i]);
                    Orion.Print("check_marked:" + check_marked);
                    if (check_marked == false)
                    {
                        positionText = String(panResult.tile[0]) + ',' +
                            String(panResult.tile[1]) + ',' + String(panResult
                                .tile[2]);
                        Orion.Print("Mark This Spot as " + positionText);
                        markRune(positionText);
                        Orion.AddFakeMapObject(waterTiles[i].X()
                            .toString() + waterTiles[i].Y()
                            .toString(), '0x1F17', '0x612', waterTiles[i]
                            .X(), waterTiles[i].Y(), waterTiles[i]
                            .Z());
                        Orion.Say('[e woohoo');
                    }
                    else
                    {
                        Orion.Print("Spot already marked at " + check_marked);
                    }
                }
                //}
            }
            else
            { // panResult is boolean
                if (panResult == false)
                {
                    Orion.AddFakeMapObject(waterTiles[i].X()
                        .toString() + waterTiles[i].Y()
                        .toString(), '0x181A', '0x25', waterTiles[i].X(),
                        waterTiles[i].Y(), waterTiles[i]
                        .Z());
                    break;
                }
                else
                {
                    break;
                }

            }

        }

    }
    Orion.Wait(middlePause);
    trashLoot();
    Orion.Wait(middlePause);
    fillGoldKey();
    Orion.Wait(middlePause);
    clearMiBs(extractMiBs);
    Orion.Wait(middlePause);
    Orion.CharPrint('self', 82, "All spots analyzed");
    Orion.Wait(middlePause);
    return true;
}



function goHome()
{
    Orion.PlayMacro("gohome");
}



function CheckAntiMacro()
{

    while (true)
    {
        while (Orion.GetLastGump() == null || Orion.GetLastGump().Replayed() ||
            Orion.GetLastGump().Text(0) != "AFK Captcha")
        {
            Orion.Wait(100);
        }

        Orion.Print("Captcha!");
        Orion.CharPrint("self", 1990, "Captcha!");
        Orion.Sound(1341);
        Orion.Sound(519);
        Orion.Sound(1634);
    }
}


function PanForGold_RunebookTravel()
{
    // 1 - get books
    // 2 - open books
    // 3 - list spots
    // 4 - recall spot
    // 5 - pan spot
    
    all_runebooks = Orion.FindType('0x22C5', '0x0000');
    panning_books = [];
    if (all_runebooks.length > 0)
    {
    		for (var i = 0; i < all_runebooks.length; i++) 
    		{
    	
	    		runebook=all_runebooks[i];
	    		book_name = getNuggetsBookName(runebook);
	    		if (book_name != false) 
   	 			{
	    			panning_books.push(runebook);
    			}
    	
	    	}
	}

        
     if (all_runebooks.length == 0 || panning_books.length == 0 ) 
     {
	    Orion.Print("no runebook to run");
	    return false;
     }
     

		for (var i = 0; i < panning_books.length; i++) 
		{
					Orion.Wait(2000);
					Orion.UseObject(panning_books[i]);
					Orion.Wait(smallPause);
					positions = readRunebookPositions(panning_books[i]);
					for (var j = 0; j < positions.length; j++) 
					{
						Orion.Wait(5000);
						Orion.UseObject(panning_books[i]);
						gumpButton = 6 * (j+1) + 1;
						Orion.Print("Recalling to spot #{0}@{1} coord. X{2}/Y{3}/Z{4}".format(
								(j+1), getNuggetsBookName(panning_books[i]), 
								positions[j].X, positions[j].Y, positions[j].Z)
						);
						Orion.WaitGump(Orion.CreateGumpHook(gumpButton));
						Orion.Wait(3000);
						do
						{
							panResult = handlePanResult(positions[j].X, positions[j].Y, positions[j].Z);
							//Orion.Print("Got " + panResult);
						} while (panResult != false)

					}

			
		}
		Orion.Wait(1500);
		trashLoot();
		Orion.Wait(middlePause);
		fillGoldKey();
		Orion.Wait(middlePause);
		clearMiBs(extractMiBs);	
   	   Orion.Print("All books panned. Returning Home");
   	   goHome();
	    return true;
}