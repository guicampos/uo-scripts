// Version 3.0 - one true main feature function, every feature with it's own handler, 
combatMode_default = 'cmode'; // default when reseting
min_jewelry_skill = 13; // >= +10 mace fighting for example
qty_jewelry_skill = 2; // how many skills to grab?  swords+tactics = 2; swords+tactics+anatomy = 3, so on
hits_limit = 85 //this is%, not absolute value

// Configure all here! you can edit but be careful. Try to edit only defaults values or delay numbers.
// ALWAYS execute the voice command '.reload' after changing any value.
features = [
{
    'name': 'World Saves',
    'command': '.ws',
    'defaultv': 'on',
    'type': 'handler',
}, 
{
    'name': 'Crowd Mode',
    'command': '.cm',
    'defaultv': 'on',
    'type': 'combatmode',
    'ability': 'Secondary',  // can be: Primary, Secondary, Lightning Strike, Honorable Execution, or any other ability or spell.
    'range': 1,
    'dress': 'championset'
},
{
    'name': 'Single Mode',
    'command': '.sm',
    'defaultv': 'on',
    'type': 'combatmode',
    'ability': 'Lightning Strike', // can be: Primary, Secondary, Lightning Strike, Honorable Execution, or any other ability or spell.
    'range': 1,
    'dress': 'championset'
},
{
    'name': 'Ranged Mode',
    'command': '.rm',
    'defaultv': 'on',
    'type': 'combatmode',
    'ability': 'Primary',  // can be: Primary, Secondary, Lightning Strike, Honorable Execution, or any other ability or spell.
    'range': 8,
    'dress': 'rangedset'
},
{
    'name': 'Consecrate Weapon',
    'command': '.acw',
    'defaultv': 'on',
    'type': 'common_spell',
    'spellname': 'Consecrate Weapon',
    'mana': '8',
    'cooldown': 7000,
    'recovery': 500,
},
{
    'name': 'Divine Fury',
    'command': '.adf',
    'defaultv': 'on',
    'type': 'common_spell',
    'spellname': 'Divine Fury',
    'mana': '12',
    'cooldown': 17000,
    'recovery': 500,
},
{
    'name': 'Evasion',
    'command': '.aev',
    'defaultv': 'on',
    'type': 'common_spell',
    'spellname': 'Evasion',
    'mana': '12',
    'cooldown': 22000,
    'recovery': 500,
},
{
    'name': 'Counter Attack',
    'command': '.aca',
    'defaultv': 'on',
    'type': 'common_spell',
    'spellname': 'Counter Attack',
    'mana': '12',
    'cooldown': 8000,
    'recovery': 500,
},
{
    'name': 'Wither',
    'command': '.aw',
    'defaultv': 'off',
    'type': 'common_spell',
    'spellname': 'Wither',
    'mana': '23',
    'cooldown': 800,
    'recovery': 500,
},
{
    'name': 'Self Bandage',
    'command': '.band',
    'defaultv': 'on',
    'type': 'handler'
},
{
    'name': 'Get Gold',
    'command': '.gg',
    'defaultv': 'off',
    'func': 'getGold',
    'type': 'onetime_function'
},
{
    'name': 'Smart Honor',
    'command': '.ahon',
    'defaultv': 'off',
    'type': 'handler',
},
{
    'name': 'Smart Looter',
    'command': '.al',
    'defaultv': 'on',
    'type': 'handler'
},
{
    'name': 'Reload Globals',
    'command': '.reload',
    'defaultv': 'off',
    'type': 'onetime_function'
},
{
    'name': 'Paperdoll Opener',
    'command': '.ppd',
    'defaultv': 'on',
    'type': 'handler',
    'cooldown': 5000,
},
{
    'name': 'Show Help',
    'command': '.help',
    'type': 'onetime_function'
},
{
    'name': 'Status Gump',
    'command': '.status',
    'type': 'onetime_function'
},
{
    'name': 'Poor Mans Master Key',
    'command': '.kk',
    'type': 'onetime_function'
},
{
    'name': 'Heal Pet',
    'command': '.hp',
    'type': 'handler',
},
];



system_name = "Advanced Combat System with Voice Commands"
system_version = "v3.0"
pulse_time = 150;
abilities_delay = 600
// --------------------

kickstart_list = [ 
    "handleWorldSaves",
    "handleFeatures",
    "handleCombatMode",
    "handleCombatSpells",
];

/**
* Initialize all default globals variables and timers.
*
* @param force Forces clearing and reinitializing all global variables and timers.
*/

function system_initialization(force)
{
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    Orion.Print(1989, 'System '+ system_name + ' ' + system_version + ' start.');
    if (Orion.ScriptRunning('handleCombatMode') == 0)
    { // script is not running. Execute all.
        init_variables(force);
        
        for (var i = 0; i < kickstart_list.length; i++)
        {
	        Orion.Exec(kickstart_list[i]);
	        Orion.Wait(10);
        }
    }
    else if (Orion.ScriptRunning('handleCombatMode') > 0)
    { // script is running. Suspend all
        suspendAllScripts();
    }
    else if (Orion.ScriptRunning('handleCombatMode') < 0)
    { // < 0. System is suspended. resume all
        resumeAllScripts();
    }
}

function init_variables(force)
{
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (force == true || !Shared.GetVar('initialized') || Shared.GetVar('initialized') != 'yes')
    { // reset system and iinitialize all default states
        
        Shared.ClearVars();

        // Timers and global vars for each feature
        for (var i = 0; i < features.length; i++)
        {
            // init timers
            if (!Orion.TimerExists(features[i].name))
            {
                Orion.SetTimer(features[i].name, 0)
            }
            // init vars
            Shared.AddVar(features[i].name, features[i].defaultv);
            Shared.AddVar('initialized', 'yes');
        }
        // Aditional timers
        if (!Orion.TimerExists('abilityTimer'))
        {
            Orion.SetTimer('abilityTimer', 0)
        }
        if (!Orion.TimerExists('honoredListCleanup'))
        {
            Orion.SetTimer('honoredListCleanup', 0);
        }
        if (!Orion.TimerExists('recoveryTimer'))
        {
            Orion.SetTimer('recoveryTimer', 0);
        }
        if (!Shared.GetVar('currentRecoveryDelay'))
        {
            Shared.AddVar("currentRecoveryDelay", 0);
        }
    }
}

function suspendAllScripts()
{
    suspendScript("all", 'handleFeatures|handleWorldSaves');
    Orion.Wait(10);
    Orion.Print('All scripts suspended.');
}

function resumeAllScripts()
{
    resumeScript("all");
    Orion.Wait(10);
    Orion.Print('Resuming all scripts.');
}

function suspendScript(scriptName, dont_stop)
{
    var scriptName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
    var dont_stop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    Orion.PauseScript(scriptName, dont_stop);
}

function resumeScript(scriptName)
{
    var scriptName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
    Orion.ResumeScript(scriptName);
}

function checkToggleFeature(feature)
{
    if (Orion.InJournal(feature.command, 'self'))
    {
        Orion.ClearJournal();
        if (features[i].type == 'combatmode')
        {
            Shared.RemoveVar(feature.type);
            Shared.AddVar(feature.type, feature.name);
            Orion.Print(feature.name + ' enabled.');
        }
        else
        {
            new_status = Shared.GetVar(feature.name) == 'on' ? 'off' : 'on';
            Shared.RemoveVar(feature.name);
            Shared.AddVar(feature.name, new_status);
        }
    }
}

function handleFeatures()
{
    while (true)
    {
        for (var i = 0; i < features.length; i++)
        {
            feature = features[i];

            checkToggleFeature(feature);

            if (feature.type == "handler")
            {
                scriptName = feature.name.replace(' ', '')+"Handler";
                if (scriptName && this[scriptName] != undefined)
                {
                    if (Shared.GetVar(feature.name) == 'on')
                    {
                        if (Orion.ScriptRunning(scriptName) == 0)
                        {
                            Orion.Exec(scriptName, true);
                        }
                        else
                        {
                            resumeScript(scriptName);
                        }
                        
                    }
                    else // feature is off
                    {
                        suspendScript(scriptName);
                    }
                }
            }
        }
        Orion.Wait(pulse_time);
    }
}














/**
 * Features handlers implementations
 * Naming format: 'feature name' 
 * without spaces + 'handler'
 * 
 * Always wrap in a while(true) loop, 
 * because handlers should be running
 * all the time and be stopped only when 
 * the feature handle identified an 'off'
 * status and suspend the feature handler.
 */


function SelfBandageHandler()
{
	var bandagedelay = 4000;
    while (true)
    {
        if (Orion.Timer('autoBandageSelf') >= bandagedelay && !Player.Dead() && (Player.Hits('%') < hits_limit || Player.Poisoned()))
        {
            Orion.BandageSelf();
            Orion.SetTimer('autoBandageSelf', 0);
        }        

        Orion.Wait(pulse_time);
    }
}

function HealPetHandler()
{
    var petHealingTimer = 2500;
    if (!Orion.ObjectExists("mypet"))
    {
        Orion.Print("Target your mount");
        Orion.WaitForAddObject("mypet");
        Orion.Wait(10);
    }
    petObject = Orion.FindObject(Orion.GetSerial("mypet"));
    var Timer, Msg = "You finish applying bandages.";
    while (!Player.Dead() && Orion.Count('0x0E21'))
    {
        //calculating pet hp percentages
        var myPetHpPercentage = petObject.Hits() * 100 / petObject.MaxHits();
        //CheckHp percentages start heal if one of the pets have lower than 95% hp
        if (myPetHpPercentage < 85)
        {
            //If petOne has lower or eqaul hp to petTwo heal petOne, else heal petTwo
            Orion.Print('-1', 'Attempting to heal your pet:' + petObject.Name());
            //Orion.UseObject('bandage');
            var bandageType = '0x0E21';
            Orion.UseType(bandageType);
            Orion.WaitTargetObject(petObject.Serial());
            Timer = Orion.Now() + petHealingTimer;
            while (Orion.InJournal(Msg) || Orion.Now() < Timer)
            {
                Orion.Wait(10);
                continue;
            }
        }
        else
        {
            Orion.Wait(10);
        }
    }
}

function SmartHonorHandler()
{
    if (!Orion.TimerExists('honoredListCleanup'))
    {
        Orion.SetTimer('honoredListCleanup', 0);
    }
    while (true)
    {
        if (Orion.Timer("honoredListCleanup") > 120000)
        {
            Orion.ClearIgnoreList('honoredList');
            Orion.SetTimer("honoredListCleanup", 0);
        }
        searchHonor();
        Orion.Wait(pulse_time);
    }
}


function listHonored()
{
    if (!honoredList)
    {
        var honoredList = Orion.GetIgnoreList('honoredList');
    }
    list_items = honoredList.Items()
    resultlist = []
    for (i = 0; i < list_items.length; i++)
    {
        if (list_items[i] || list_items[i] != null || list_items[i] != undefined)
        {
            resultlist.push(list_items[i].Serial())
        }
    }
    return resultlist;
}

function searchHonor()
{
    var targets = Orion.FindTypeEx(any, any, 'ground', "live|ignoreself|mobile|inlos", 6, "gray|criminal|orange|red");
    honoredList = listHonored()
    for (i = 0; i < targets.length; i++)
    {
        if (targets[i].Hits('%') <= 0)
        {
            Orion.GetStatus(targets[i].Serial());
            Orion.Wait(pulse_time);
        }
        if (honoredList.contains(targets[i].Serial()) != true && targets[i].Hits('%') == 100 && Orion.InLOS(targets[i]
                .Serial()))
        {
            applyHonor(targets[i]);
        }
    }
}

function applyHonor(target)
{
    if (!target || target == undefined)
    {
        return false;
    }
    if (!honoredList)
    {
        var honoredList = Orion.GetIgnoreList('honoredList');
    }
    Orion.InvokeVirtue('Honor');
    Orion.WaitTargetObject(target.Serial());
    list_items = honoredList.Items()
    list_items.push(new IgnoreListItem('any', 'any', target.Serial(), target.Name()))
    honoredList.SetItems(list_items);
    Orion.AddHighlightCharacter(target.Serial(), '0x513');
    Orion.UpdateIgnoreList(honoredList);
    Orion.Wait(600);
}

Array.prototype.contains = function (obj)
{
    var i = this.length;
    while (i--)
    {
        if (this[i] === obj)
        {
            return true;
        }
    }
    return false;
}

function SmartLooterHandler()
{

    while (true)
    {
        corpse_nearby = Orion.FindType('0x2006|0x2DF3', 'any', 'ground');

        if (!corpse_nearby || corpse_nearby.length <= 0)
        {
            continue;
        }
        for (var k = 0; k < corpse_nearby.length; k++)
        {
            Orion.UseObject(corpse_nearby[k]);
            Orion.Wait(300);
            Orion.Ignore(corpse_nearby[k]);

            matches = 0;
            jewelry_in_corpse = Orion.FindTypeEx('0x108a|0x1f09|0x1086|0x1f06', 'any', corpse_nearby[k]);
            for (var i = 0; i < jewelry_in_corpse.length; i++)
            {
                var properties_found = []
                properties_found = PullProperty(jewelry_in_corpse[i], skill_list);
                if (properties_found && properties_found.length >= qty_jewelry_skill)
                {
                    Orion.MoveItem(jewelry_in_corpse[i].Serial(), 1, 'backpack');
                    Orion.Wait(600);
                    Orion.Print('2226', '?' + jewelry_in_corpse[i].Name() + ' found with ' + properties_found.length +
                        ' skill' + (properties_found.length > 1 ? 's' : '') + ' >=' + min_jewelry_skill);
                    for (var j = 0; j < properties_found.length; j++)
                    {
                        Orion.Print('2226', '   ' + properties_found[j][1] + ' - ' + properties_found[j][2]);
                    }
                    Orion.Say("[e oh");
                }
            }
				// Others by graphic and color. Always place the correspoding color in the same position as the graphic.
            others_in_corpse_graph = ['0x0C6A', '0x1CED', '0x21FE', '0x18E5', '0x0F3B', '0x187E', '0x0D16', '0x0E27', '0x0F7E', '0x10E7', ] ;
            others_in_corpse_color  = ['0x04EB', '0x056C', '0x0000', '0x0000', '0x0000', '0x0000', '0x056C', '0x0003', '0x0000', '0x0000', ];

            for (var i = 0; i < others_in_corpse_graph.length; i++)
            {
                 Orion.MoveItemType(others_in_corpse_graph[i], others_in_corpse_color[i], corpse_nearby[k], 0, 'backpack');
            }
        }
        Orion.Wait(pulse_time);
    }
}

function PullProperty(item, skill)
{
    if (item)
    {
        searchResult = []
        var itemPropLines = item.Properties().split(/\n|\r/);
        for (var j = 0; j < itemPropLines.length; j++)
        {
            var regex = "(" + skill + ")" + "\\s+\\+(\\d+)";
            var search = itemPropLines[j].match(regex);
            if (search && search != undefined && search[2] >= min_jewelry_skill)
            {
                searchResult.push(search);
            }
        }
        return searchResult;
    }
}

function PaperdollOpenerHandler()
{

    while (true)
    {
        if (Orion.Timer('openPaperdoll') >= 3000)
        {
            Orion.OpenPaperdoll("self");
            Orion.SetTimer('openPaperdoll', 0);
        }
        Orion.Wait(pulse_time);
    }

}

function findEnemies(searchrange, findflag, notoriety)
{
    if (!searchrange)
    {
        searchrange = 10;
    }
    var mobs = Orion.FindType(any, any, 'ground', findflag, searchrange, notoriety);
    return mobs;
}

function acquireTarget(range)
{

    closest_enemy = findEnemies(range, "live|ignoreself|mobile|fast|near", "gray|criminal|orange|red");
    if (closest_enemy && Orion.ObjectExists(closest_enemy))
    {
        Orion.AddObject('closest_enemy', closest_enemy);
        return closest_enemy;
    }
    else
    {
        Orion.RemoveObject('closest_enemy');
    }
    Orion.Wait(pulse_time);
}

function handleCombatMode()
{
    while (true)
    {
        currentMode = Shared.GetVar('combatmode') ? Shared.GetVar('combatmode') : combatMode_default;
        enemy = acquireTarget(featuresIndexed[currentMode].range);
        Orion.Wait(15);
        Orion.Dress(featuresIndexed[currentMode].dress);
        if (Orion.ObjectExists(enemy))
        {
            attackTarget(featuresIndexed[currentMode].ability);
        }
        Orion.Wait(pulse_time);
    }
}

function attackTarget(ability)
{
    if (Orion.Timer('abilityTimer') >= 600 && Orion.Timer('recoveryTimer') >= Shared.GetVar("currentRecoveryDelay"))
    {
        if ((ability == 'Secondary' || ability == 'Primary'))
        {
            if (!Orion.AbilityStatus(ability))
            {
                Orion.UseAbility(ability);
                Orion.SetTimer('abilityTimer', 0);
                Orion.SetTimer('recoveryTimer', 0);
                Shared.GetVar("currentRecoveryDelay", 300);
            }
        }
        else
        {
            if (!Orion.SpellStatus(ability))
            {
                Orion.Cast(ability)
                Orion.SetTimer('abilityTimer', 0);
                Orion.SetTimer('recoveryTimer', 0);
                Shared.GetVar("currentRecoveryDelay", 300);
            }
        }
        Orion.AddDisplayTimer('abilityTimer', 600, 'LeftBottom', 'Line|Bar|Vertical', 'abilityTimer', 120, 0, '1990', -
            1, '0xFD')
    }
    Orion.Attack(Orion.GetSerial('closest_enemy'));
    Orion.Wait(pulse_time);
}

function handleCombatSpells()
{
    while (true)
    {
        for (var i = 0; i < features.length; i++)
        {
            if (!features[i].type || (features[i].type && features[i].type != 'auxspells'))
            {
                continue;
            }
            spelltocast = features[i].spellname;
            mana = features[i].mana;
            cooldown = features[i].cooldown;
            recovery = features[i].recovery;
            has_target = features[i].has_target;
            target = null;
            if (has_target)
            {
                target = Orion.GetSerial('closest_enemy');
            }
            if (!Orion.TimerExists(spelltocast))
            {
                Orion.SetTimer(spelltocast, cooldown + 1);
            }
            if (features[i].func && this[features[i].func] != undefined)
            {
                this[features[i].func](spelltocast, mana, cooldown, recovery, target, i);
                Orion.Wait(10);
            }
            else
            {
                Orion.Print(1989, 'WARNING: function ' + features[i].func + ' for spell ' + spelltocast + ', feature ' +
                    features[i].name + ' is uniplemented')
                continue;
            }
            Orion.Wait(10);
        }
        Orion.Wait(pulse_time);
    }
}

function common_cast(spellname, mana, cooldown, recovery, target, position)
{
    if (Player.Mana() >= mana && Orion.Timer(spellname) >= cooldown && Orion.Timer('recoveryTimer') >= Shared.GetVar(
            "currentRecoveryDelay"))
    {
        if (!target)
        {
            if (spellname == 'Counter Attack' && Orion.Timer('evasionTimer') <= 10000)
            {
                return false;
            }
            Orion.Cast(spellname);
        }
        else
        {
            Orion.CastTarget(spellname, target);
        }
        Orion.SetTimer(spellname, 0);
        Orion.SetTimer('recoveryTimer', 0);
        Shared.AddVar("currentRecoveryDelay", recovery);
        Orion.AddDisplayTimer(spellname, cooldown, 'Bottom', 'Line|Bar', spellname.replace(' ', '\r\n'), (position *
            65), 0)
        Orion.AddDisplayTimer('currentRecoveryDelay', recovery, 'LeftBottom', 'Line|Bar', 'recovery_delay', 0, 0, '87',
            -1, '0xFD')
        return true;
    }
    return false;
}

/**
 * One time only functions 
 * They don't have a handler and are executed once and return. 
 * 
 */

 function GetGold()
 {
         goldPileGraphic = '0x0EED';
 
         Orion.FindType(goldPileGraphic, 'any', 'ground', 'item', 20) // bloody weird javascript syntax
         .forEach(function(gold)
         {
                 Orion.UseObject(gold);
                 Orion.Wait(50);
         }
         );
 }

 function PoorMansMasterKey()
{
	// Order by most used/needed. Don't worry if you don't have a key. The script will ignore it.
    storageKeyArray = [
    {
        'graphic': "0x2FEA",
        'name': "Gem Storage",
        'color': "0x0482"
    },
    {
        'graphic': "0x0FBE",
        'name': "Scribe's Tome",
        'color': "0x0000"
    },
    {
        'graphic': "0x18DE",
        'name': "Reagent Keys",
        'color': "0x0021"
    },
    {
        'graphic': "0x14EE",
        'name': "Treasure Hunter's Storage",
        'color': "0x0745"
    },
    {
        'graphic': "0x2259",
        'name': "Ultimate Power Scroll Book",
        'color': "0x0481"
    },
    {
        'graphic': "0x1EBA",
        'name': "Runic Tool Box",
        'color': "0x0041"
    },
    {
        'graphic': "0x1EBB",
        'name': "Tool Box",
        'color': "0x002D"
    },
    {
        'graphic': "0x09A8",
        'name': "Jewelry Box",
        'color': "0x0000"
    },
    {
        'graphic': "0x1BD9",
        'name': "Wood Storage",
        'color': "0x0058"
    },
    {
        'graphic': "0x177C",
        'name': "Stone Storage",
        'color': "0x0489"
    },
    {
        'graphic': "0x1BE8",
        'name': "Ingot Keys",
        'color': "0x0014"
    },
    {
        'graphic': "0x0F9D",
        'name': "Tailor Store",
        'color': "0x0044"
    },
    {
        'graphic': "0x185E",
        'name': "Potion Storage",
        'color': "0x0030"
    }, 
/*    {
        'graphic': "0x11C6",
        'name': "Evo Key",
        'color': "0x0501"
    },
*/
    
];

    for (i = 0; i < storageKeyArray.length; i++)
    {
        keyinfo = storageKeyArray[i];
        keystorage = Orion.FindType(keyinfo.graphic, keyinfo.color, 'backpack', 'item|fast');
        if (keystorage && keystorage != undefined)
        {
            Orion.RequestContextMenu(keystorage);
            Orion.WaitContextMenuID(keystorage, 2);
            Orion.CharPrint(keystorage, -1, keyinfo.name);
            if (Orion.WaitForGump(1000))
            {
                var gump0 = Orion.GetGump('last');
                if ((gump0 !== null) && (!gump0.Replayed()) && (gump0.ID() === '0x06ABCE12'))
                {
                    gump0.Select(Orion.CreateGumpHook(0));
                }
            }
            Orion.Wait(300);
        }
    }
     Orion.CancelContextMenu();
}

function StatusGump()
{
    // Create new custom gump with serial 15
    var gump = Orion.CreateCustomGump(15);

    gump.Clear();

    // Main background
    gump.AddResizepic(0, 0, '13BE', 1250, 250 + (features.length * 12));
    var itemSerial = 1;

    var step = 25;
    var stepx = 25;
    var x = 5;
    var y = 2;
    gump.AddText(x, y, '1990', "Status for " + system_name + ' ' + system_version);
    y += step;
    gump.AddText(x, y, '0', "Name: {name}");
    y += step;
    for (var i = 0; i < features.length; i++)
    {
        gump.AddText(25, y, (Shared.GetVar(features[i].name) == 'on' ? 1696 : 1688), "[" + Shared.GetVar(features[i]
            .name) + "] ");
        gump.AddText(60, y, 1291, features[i].name);
        gump.AddText(180, y, 1291, JSON.stringify(features[i]));
        //		   continue;
        y += step;
        stepx += stepx;
    }
    // Commit gump changes and update it in client
    gump.Update();
}