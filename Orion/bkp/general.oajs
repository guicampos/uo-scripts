//#include main.oajs

function TameAllAnimals()
{
    TargetList1 = '0x00E7|0x00D8' // cow
    TargetList2 = '0x00D0' //chicken
    TargetList3 = '0x0030' // scorpion
    TargetList4 = '0x004A'; // imp
    TargetList5 = '0x003B|0x000C'; // dragon
    TargetList = TargetList5;
    while (true)
    {
        target = Orion.FindType(TargetList, 'any', 'ground', 'ignoreself|mobile|live|near|inlos', 8)[0];
        Orion.AddHighlightCharacter(target, '1990');
        AnimalTaming(target);
        Orion.Wait(pulse_time);
    }
}

function AnimalTaming(target)
{
    var endMsg = "anger the beast|you fail to tame";
    var stopMsg = "cannot be tamed|accept you as master|tame already";
    var allMsg = endMsg + "|" + stopMsg;
    var start = Orion.Now();
    var delay = 5000;
    //    if (Orion.WaitForAddObject("temp") != 1)
    //   {
    //        Orion.Print("AnimalTaming canceled");
    //       return;
    //    }
    var mount = Orion.FindObject(target);
    if (!mount)
    {
        return false;
    }
    while (mount.Exists() && !Orion.InJournal(stopMsg, "", "0", any, start))
    {
        Orion.Follow(target);
        start = Orion.Now();

        mobs = Orion.FindTypeEx(TargetList, 'any', 'ground', 'ignoreself|mobile|live', 10);
        for (var i = 0; i < mobs.length; i++)
        {
            if (mobs[i].Notoriety() < 4)
            {
                Orion.CharPrint(mobs[i].Serial(), 1990, 'this');
                Orion.Say('All Stop');
                Orion.UseObject('0x43FD925C')
                Orion.WaitForTarget(1500);
                Orion.Wait(1000);
                Orion.TargetObject(mobs[i].Serial())
                break;
            }
        }
        //		Orion.UseSkillTarget('Peacemaking', mount.Serial());

        Orion.Wait(pulse_time);
        Orion.WaitTargetObject(mount.Serial());
        Orion.UseSkill("Animal Taming");
        Orion.WaitJournal(allMsg, start, start + delay);
        Orion.Wait(pulse_time);
        Orion.CancelTarget();
    }
}


// Lumber variables
var maxSearchDistance = 20;
var axe = '0x0F4B';

function CutTreeByWorldLoc()
{
    Orion.ClearJournal();
    var treeWorldLocation = FindTreesInSurrArea();
    for (i = 0; i < treeWorldLocation.length; i++)
    {
        Orion.Print('Chopping tree. ' + (treeWorldLocation.length - i) + ' trees left to chop. ');
        Orion.RequestContextMenu('0x47C25209');
        Orion.WaitContextMenuID('0x47C25209', 2);
        if (Orion.WaitForGump(1000))
        {
            var gump0 = Orion.GetGump('last');
            if ((gump0 !== null) && (!gump0.Replayed()) && (gump0.ID() === '0x06ABCE12'))
            {
                gump0.Select(Orion.CreateGumpHook(0));
                Orion.Wait(pulse_time);
            }
        }
        Orion.Wait(500);
        Orion.WalkTo(treeWorldLocation[i][0], treeWorldLocation[i][1], 0);
        Orion.Wait(2000);
        Orion.UseType(axe); //??? ??????
        Orion.WaitTargetTile('tree', treeWorldLocation[i][0], treeWorldLocation[i][1], 0);
        Orion.Wait(2000);
        var mobs = Orion.FindEnemy('near|mobile', '2', 'gray|criminal|red');
        if (mobs.length) Orion.Exec("init_acswvc_system", true)
        if (Orion.InJournal('in your backpack|but fail to produce', 'sys'))
        {
            LumberAgain(treeWorldLocation[i][0], treeWorldLocation[i][1]);
        }
    }
}

function FindTreesInSurrArea()
{
    var treeWorldLocations = createArr(400, 400);
    var trueWorldLocCounter = 0;
    for (i = (Player.X() - maxSearchDistance); i < (Player.X() + maxSearchDistance + 1); i++)
    {
        for (j = (Player.Y() - maxSearchDistance); j < (Player.Y() + maxSearchDistance + 0); j++)
        {
            if (Orion.ValidateTargetTile('tree', i, j))
            {
                Orion.Print("Found a tree, location is saved as " + (trueWorldLocCounter + 1));
                treeWorldLocations[trueWorldLocCounter][0] = i;
                treeWorldLocations[trueWorldLocCounter][1] = j;
                trueWorldLocCounter++;
            }
        }
    }
    treeWorldLocations.length = trueWorldLocCounter;
    return treeWorldLocations;
}

function LumberAgain(x, y)
{
    var text = 'wood here to harvest|no logs|have been destroer|too far away|You can';
    while (!Player.Dead())
    {
        Orion.RequestContextMenu('0x47C25209');
        Orion.WaitContextMenuID('0x47C25209', 2);
        if (Orion.WaitForGump(1000))
        {
            var gump0 = Orion.GetGump('last');
            if ((gump0 !== null) && (!gump0.Replayed()) && (gump0.ID() === '0x06ABCE12'))
            {
                gump0.Select(Orion.CreateGumpHook(0));
                Orion.Wait(pulse_time);
            }
        }
        Orion.UseType(axe); //??? ??????
        Orion.WaitTargetTile('tree', x, y, 0);
        var msg = Orion.WaitJournal(text, Orion.Now(), Orion.Now() + 5000, 'sys|my');
        if (msg != null) break;
        Orion.Wait(1000);
    }
    Orion.ClearJournal();
}

function TrainDiscordance()
{
    types = "0x00D5|0x001E|0x005A|0x0080|0x019|0x033D"
    while (true)
    {
        target = Orion.FindType(types, 'any', 'ground', 'near|fast');
        Orion.UseSkill('Discordance');
        Orion.WaitForTarget(1000);
        if (Orion.InJournal('shall you play', 'system'))
        {
            Orion.Wait(2000);
            Orion.TargetType('0x0E9D', 'any', 'backpack');
            Orion.ClearJournal();
        }
        Orion.Wait(1000);
        Orion.WaitTargetObject(target);
        while (Orion.InJournal('You attempt to disrupt', 'system'))
        {
            Orion.UseSkill('Discordance');
            Orion.Wait(1000);
            Orion.WaitTargetObject(target);
            Orion.ClearJournal();
        }
        if (Orion.InJournal('suppressing', 'system') || Orion.InJournal('is already', 'system'))
        {
            Orion.Wait(1000);
            Orion.Cast('Invisibility');
            Orion.WaitTargetObject('self');
            Orion.Wait(18000);
            Orion.ClearJournal();
        }
        Orion.Wait(3000);
    }
}

function mine()
{
    Orion.ClearJournal('mine there');
    Orion.ClearJournal('no metal here');
    while (true)
    {

        if (!Orion.UseType('0x0E85')) break;
        Orion.WaitTargetTile('mine');
        Orion.Wait(1000);

        if (Orion.LastJournalMessage().Text().indexOf('overloaded'))
        {
            ores = Orion.FindType('0x19B7|0x19B8|0x19B9|0x19BA', 'any');

            for (var i = 0; i < ores.length; i++)
            {
                Orion.UseObject(ores[i]);
                Orion.WaitForTarget(2000);
                Orion.TargetObject('0x4233FDB4')
            }

            Orion.RequestContextMenu('0x468639AA');
            Orion.WaitContextMenuID('0x468639AA', 2);
            if (Orion.WaitForGump(1000))
            {
                var gump0 = Orion.GetGump('last');
                if ((gump0 !== null) && (!gump0.Replayed()) && (gump0.ID() === '0x06ABCE12'))
                {
                    gump0.Select(Orion.CreateGumpHook(0));
                    Orion.Wait(pulse_time);
                }
            }

        }
    }
}

function searchTreasureSpot()
{

//    while (true)
    {
        tiles = Orion.GetTilesInRect('land', Player.X()-3, Player.Y()-3, 0, Player.X()+3 , Player.Y() +3,0);
        	            Orion.Print(tiles.length)
        for (i = 0; i < tiles.length; i++)
        {
            Orion.AddFakeMapObject(Orion.Random(0, 65000) + i, '0x023E', '0x0021', tiles[i].X(), tiles[i].Y(), tiles[i].Z());
            Orion.Wait(5);
        }
        Orion.Wait(600);
        for (i = 0; i < tiles.length; i++)
        {
            Orion.AddFakeMapObject(Orion.Random(0, 65000) + i, '0x023E', '0x0000', tiles[i].X(), tiles[i].Y(), tiles[i].Z());
			tmap = Orion.FindType('0x14EC', '0x08AB', backpack, 'item|fast', '', false);
            Orion.RequestContextMenu(tmap);
            Orion.WaitContextMenuID(tmap, 1);
            if (Orion.WaitForTarget(2000))
            {
                Orion.AddFakeMapObject(Orion.Random(0, 65000), '0x023E', '0x04F8', tiles[i].X(), tiles[i].Y(), tiles[i].Z())
	            Orion.Print('Digging')
                Orion.Wait(400);
                Orion.TargetTile('any', tiles[i].X(), tiles[i].Y(), tiles[i].Z());
            }
        }
    }

}




function SortingItems()
{
    var obj = { type: 0x14F0, color: 0x0000 };
    var posX = { start: 5, end: 120, offset: 15 };
    var posY = { start: 5, end: 130, offset: 25 };
    var i = 0;

    posX.count = Math.floor((posX.end - posX.start) / posX.offset);
    posX.start += Math.floor(((posX.end - posX.start) - (posX.offset * posX.count)) / 2);

    posY.count = Math.floor((posY.end - posY.start) / posY.offset);
    posY.start += Math.floor(((posY.end - posY.start) - (posY.offset * posY.count)) / 2);


    var items = Orion.FindTypeEx(obj.type, obj.color, backpack);

    for (var y = posY.start; y <= posY.start + (posY.offset * posY.count); y += posY.offset)
    {
        for (var x = posX.start; x <= posX.start + (posX.offset * posX.count); x += posX.offset)
        {
            if (!items.length || i > items.length - 1)
            {
                return;
            }

            var item = items[i];

            if (item.X() != x || item.Y() != y)
            {
                Orion.MoveItem(item.Serial(), 0, lastcontainer, x, y, 0);
                Orion.Wait(800);
            }

            ++i;
        }
    }
}


function say_buttler()
{

buttler_sayings = ["my name is Try Catch, Velland's Automated Buttler", "If you need any macro, script or programming services.", "Please reach my master's Discord at guicampos#6410", "You can also mail him in game using PM.", "Thank you and good shopping!"];
	while (! Player.Dead()) 
	{
		 var humans = Orion.FindTypeEx(any,any,ground,'human|live|ignoreself',8,'blue|green|orange', false, 'PlayerDetectorIgnoreList')
		     .filter(function(human)
		         {
				    if(!human.ProfileReceived())
		                 Orion.GetProfile(human.Serial());
		             return human.ProfileReceived();
			});
		if (Orion.InJournal('what is your version'))
		{
				Orion.Say("Velland's buttler version 1.0");
				Orion.ClearJournal();
		}
		if (humans.length > 0)
		{
			player = humans[0];
			Orion.Say("Hello " + player.Name());
			Orion.Wait(2000);
			buttler_sayings.forEach(function(element)
			{
				Orion.Say(element);	
				Orion.Wait(3000);	
			});
			Orion.AddIgnoreListObject('PlayerDetectorIgnoreList', player.Serial(), player.Name());
		}
		Orion.Wait(60000);
	}
}

function ingame_chat_to_discord()
{
		function sendmessage(load)
		{
		//ufo//	var bot = "https://discord.com/api/webhooks/1042608523189698561/gfsybIRv7y5XrYVNOJPb76ZS4jEQwUMl1AwCKfcaN9aNkefhhM9WDtusDxCux8PuiGuD";
			var bot = "https://discord.com/api/webhooks/1042591595142320168/M_EW9HaG_HuRWojH7x1Sn6byhKZ52U17X3mGcvQUjeBwxLgRQ4IvhRGVx6gw0mEK_dMW"; // Webhook url
			var paramText = 'content=';
				return Orion.HttpPost(bot, paramText+load);
		}
	// Discord

	var msg = null;
	while(true)
	{
		if ((msg = Orion.InJournal('<Public> |<Trade> |<UFO> |<PVP> ')) != null)
		{
			Orion.ShowJournal(20);
			sendmessage(msg.Text());
			Orion.ClearJournal();
		}

		if ((msg = Orion.InJournal('','',0,"0x0044")) != null)
		{
			Orion.ShowJournal(20);
			name = Orion.RequestName(msg.Serial(),1500);
			if (!name)
			{
				PlayerDetectorIgnoreList = Orion.GetIgnoreList('PlayerDetectorIgnoreList');
				name = PlayerDetectorIgnoreList.Items().filter(function(cha){
					return char.Serial() == msg.Serial();
				});
			}

			sendmessage('[Guild]['+name+']'+msg.Text());
   		    Orion.ClearJournal();
		}
		
		if(msg != null)
		{
			msg = null;
		}
	Orion.Wait(200);
	}
}

function inventory_handler()
{
    Orion.ClearJournal();
	while (! Player.Dead())
	{
		map_check = Orion.InJournal('.map', 'self');
	
		if (map_check&&map_check.Text().length > 0)
		{
			Orion.Exec("inventory_map", true);
	        Orion.ClearJournal();
		}
        
		range_check = Orion.InJournal('.range', 'self');
	
		if (range_check&&range_check.Text().length > 0)
		{
            Shared.RemoveVar('range');
	        Shared.AddVar('range', range_check.Text().split(' ')[1]);
            Orion.Print('Search range is now ' + range_check.Text().split(' ')[1]);
	        Orion.ClearJournal();
		
		}

		commit_check = Orion.InJournal('.commit', 'self');
	
		if (commit_check&&commit_check.Text().length > 0)
		{
			inventory_commit();
	        Orion.ClearJournal();
		}

		stop_check = Orion.InJournal('.stop', 'self');
	
		if (stop_check&&stop_check.Text().length > 0)
		{
            Shared.RemoveVar('project_name');
            Shared.RemoveVar('range');
	        Orion.ClearJournal();
            Orion.Print('Ok, bye!');
            return true;
		}		

		reset_check = Orion.InJournal('.reset', 'self');
	
		if (reset_check&&reset_check.Text().length > 0)
		{
			Orion.ClearFakeMapObjects();
	        Orion.ClearJournal();
		}
		
		label_check = Orion.InJournal('.label', 'self');
	
		if (label_check&&label_check.Text().length > 0)
		{
	        Shared.AddVar('label', label_check.Text());
	        Orion.ClearJournal();
		}
        
		mode_check = Orion.InJournal('.containers_only', 'self');
	
		if (mode_check&&mode_check.Text().length > 0)
		{
            containers_only = Shared.GetVar('containers_only', 'off');
            Shared.RemoveVar('containers_only');
            
            if (containers_only == 'on')
                Shared.AddVar('containers_only', 'off');
            else
                Shared.AddVar('containers_only', 'on');
	        Orion.ClearJournal();
		}

	Orion.Wait(50);
	}

}

function inventory_init()
{
	project_name = Orion.InputText(60000, 'Type a project name');
	if (project_name.length <= 0)
    {
        Orion.Print(1990, 'A Project name is required.');
        return false;
    }    

	Shared.ClearVars();
	list_of_items = Orion.GetFindList(project_name);
	file_name = project_name.replace(' ', '')+'.csv';
	Shared.AddVar('project_name', project_name);
	Shared.AddVar('range', 1);
	
	Orion.Print(2213, '-=| Inventory project for'+project_name+' |=-');
	Orion.Print(2498,'  |You can now proceed to map the place using the "inventory_map" function.');	
	Orion.Print(2498,'  |Type ".map" to map an area named [.label] delimited by [.range].');
    Orion.Print(2498,'  |Type ".label" <string> to set a label for the mapping. Default empty.');
	Orion.Print(2498,'  |Type ".range" <number> to set the search range. Default 1.');
	Orion.Print(2498,'  |Type ".commit" to finish the project and generate the final csv file.');
    Orion.Print(2498,"  |Type \".containers_only\" to invertory only items inside containers, ignoring items on the ground (default 'off').");
	Orion.Print(2498,'  |Type ".quit" leave the project handler.');
	Orion.Print(2498,'created by Velland');
	
	Orion.Exec('inventory_handler', true);
	
}

function inventory_commit()
{
	var project_name = Shared.GetVar('project_name', '');	
    
	if(project_name.length < 1 )
	{
		Orion.Print('Project not initiated. Please run inventory_init first.');
		return false;
	}
	
    var csv_header = ["serial", "name", "graphic", "color", "is container", "Contents Count", "parent container serial", "parent container name", "XYZ location", "level", "label", "all details"];	
	file_name = Orion.CurrentScriptDirPath()+'/'+project_name+'.csv';
	csv_file = Orion.NewFile();
	csv_file.Open(file_name, true);
    
	if (! csv_file)
	{
		csv_file.Open(file_name);	
	    csv_file.Write(csv_header.join(';'));
	    csv_file.Write("\n");
	}
	else
	{
		csv_file.Append(file_name);		
	}

	project_list = Orion.GetIgnoreList(project_name);
	list_items = project_list.Items();
	
	list_items.forEach(function(item){
		csv_file.Write(item.Comment());
		csv_file.Write("\n");		
	});
	
	csv_file.Close();
	
	Orion.Print(list_items.length+'Lines commited to file '+file_name);
}

function inventory_report_item(item, level, label)
{
    var containers_only = Shared.GetVar('containers_only', 'off');
    if (containers_only == 'on' && item.Container() == '0XFFFFFF')
        return null;
        
    var is_container = 'no';
    var contains_qty = getContents_qty(item);

    if (contains_qty > 0) 
    {
        is_container = Orion.Contains(item.Properties(), 'Contents') != null ? 'yes' : 'no';
	    Orion.OpenContainer(item.Serial(), 1000);
        Orion.WaitForContainerGump();
    }

    parent_container_serial = item.Container() != null? item.Container() : '--';
    parent_container_name = Orion.FindObject(parent_container_serial) != null? Orion.FindObject(parent_container_serial).Name() : 'ground';
    comment_field = [item.Serial().toString(), item.Name(), item.Graphic().toString(), item.Color().toString(), is_container.toString(), contains_qty.toString(), parent_container_serial, parent_container_name, item.X().toString()+","+item.Y().toString()+","+item.Z().toString(), level, label, JSON.stringify(item.Properties())].join(';');

    return new IgnoreListItem(item.Graphic(), item.Color(), item.Serial(), comment_field);
    
}

function inventory_map()
{

	var project_name = Shared.GetVar('project_name', '');	
	if(project_name.length < 1 )
	{
		Orion.Print('Project not initiated. Please run inventory_init first.');
		return false;
	}

	range = parseInt(Shared.GetVar('range', 1));
	label = Shared.GetVar('label', '');
    containers_only = Shared.GetVar('containers_only', 'off');

	// Every mapping have a color so it's esier to check each mapping boundaries.
	color = Orion.Random(1000,2000);    
	Orion.Print(color, 'Mapping '+label);
    Orion.Print(color, 'Range['+distance+'], Containers only[' +containers_only+']');
	
	// Get the titles to be searched. It's a cube measuring X,Y,Z. 
	//Why a Cube? Because people likes to create those crazy walls full of stacked chests.
	tilesinrect = []

	for (var xsearch = Player.X() - range; xsearch  < Player.X() + range; xsearch++)
	{
		for (var ysearch = Player.Y() - range; ysearch  < Player.Y() + range; ysearch++)
		{

			for (var zsearch = Player.Z(); zsearch  < Player.Z() + 18; zsearch++)
			{
				tilesinrect.push({'x':xsearch,'y':ysearch,'z':zsearch});
			}
		}
	}

	report_lines = []
	// For each tile inside the cube, search for items.
	tilesinrect.forEach(function(tile){
			//Orion.AddFakeMapObject(tile.x.toString()+tile.y.toString()+Math.abs(tile.z).toString(), '0x3EF1', color, tile.x, tile.y, tile.z);			
		    //Orion.Wait(1);
			xyz = 'xyz: '+tile.x+','+ tile.y+','+ tile.z;
			//Orion.Print(xyz)
			Orion.FindTypeEx('any', 'any', 'ground', 'item', xyz, '', true)
			.filter(function(item){ if (item.Name() && item.Name() != "") return item})
			.forEach(function(item){
		        level=1;
		        // Level 1
		        //report items on the ground/world
                item_created = inventory_create_item(item, level, label);
                if (item_created !=null)
                    report_lines.push(item_created);
                    
		        if (Orion.Contains(item.Properties(), 'Contents'))
		        {
		            Orion.FindTypeEx('any', 'any', item.Serial(), 'item', 'finddistance', '', true).forEach(function(item)
		            {
		                level=2;
		                // Level 2
		                //report single item    
		                 report_lines.push(new IgnoreListItem(item.Graphic(), item.Color(), item.Serial(), inventory_report_item(item, level, label).join(';')));
		                if (Orion.Contains(item.Properties(), 'Contents')) 
		                {
		                    Orion.FindTypeEx('any', 'any', item.Serial(), 'item','finddistance', '', true).forEach(function(item)
		                    {
		                        level=3;
		                        // Level 3
		                        //report single item    
		                         report_lines.push(new IgnoreListItem(item.Graphic(), item.Color(), item.Serial(), inventory_report_item(item, level, label).join(';')));
		                        if (Orion.Contains(item.Properties(), 'Contents')) 
		                        {
		                                Orion.FindTypeEx('any', 'any', item.Serial(), 'item', 'finddistance', '', true).forEach(function(item)
		                                {
		                                    level=4;
		                                    // Level 4
		                                    //report single item                
		                                     report_lines.push(new IgnoreListItem(item.Graphic(), item.Color(), item.Serial(), inventory_report_item(item, level, label).join(';')));
		                                    if (Orion.Contains(item.Properties(), 'Contents')) 
		                                    {
		                                        Orion.FindTypeEx('any', 'any', item.Serial(), 'item', 'finddistance', '', true).forEach(function(item)
		                                        {
		                                            level=5;
		                                            // Level 5
		                                            //report single item
		                                            report_lines.push(new IgnoreListItem(item.Graphic(), item.Color(), item.Serial(), inventory_report_item(item, level, label).join(';')));
		                                        });
		                                    }
		                                });
		                        }
		                    });
		                }
		            });
		        }
			});
	});
	
	if (report_lines.length > 0)
	{
		var project_list = Orion.GetIgnoreList(project_name);
		var list_items = project_list.Items();
		var new_list_items = [];
		var flags = {};
		var index;
		var repeatedlist=0;
		var merged_list_items = list_items.concat(report_lines);
		//Orion.Print('list_items:'+list_items.length)
		//Orion.Print('report_lines:'+report_lines.length)
	
		if (list_items.length < 1)
			new_list_items = report_lines;
		else
		{		     	
			for (index = 0; index < merged_list_items.length; ++index) 
            {

			    if (!flags[merged_list_items[index].Serial()]) 
                {
			        flags[merged_list_items[index].Serial()] = true;
			        new_list_items.push(merged_list_items[index]);
			    }
			    else
			    	repeatedlist++;
			}
		}
	
		rep = '';
		if (repeatedlist > 0) 
			rep = '('+repeatedlist+' repetitions discarded)';
		Orion.Print((new_list_items.length-list_items.length)+' objects added to the list.'+rep);
	    project_list.SetItems(new_list_items);
	
	
		Orion.UpdateIgnoreList(project_list);	
	}

	Orion.Print(color,'End Mapping');
}

function getContents_qty(item)
{
    if (item)
    {
        searchResult = []
        var itemPropLines = item.Properties().split(/\n|\r/);
        for (var j = 0; j < itemPropLines.length; j++)
        {

            if (Orion.Contains(itemPropLines[j], 'Contents'))
            {
            	str = itemPropLines[j].substr(itemPropLines[j].lastIndexOf('Contents: ')+10,itemPropLines[j].lastIndexOf('Contents:')+2);
            	if (isNaN(str.slice(-1)))
            	{
            		str = str.substr(0,str.length-1);
            	}

                return parseInt(str);

            }
        }
    }
    return 0;
}

function al_buildcreatelists()
{
  	file = Orion.NewFile();
  	file.Open('teste.txt');
	items = Orion.FindTypeEx('any', 'any', 'ground', 'item', '10', '').filter(function(item){
		if (!Orion.Contains(item.Name(), 'Brazier|Statue|Earrings|Used|Woven|Chief|Candle|Virtue|Glimmering|Travesty|Badge|Minotaur|Amber|Maggots|Collection|Glob|Bones|Essence|Heart|Rope|Lard|Sweat|Tree|Leaves|Saliva|Abscess|Coil')) return item;
	});
	items
	.forEach(function(item){
    abrname = []
		if (item.Name() != "" ) 
		{
			words = item.Name().replace("'", "").toUpperCase().split(' ');
   		    words.forEach(function(word){
   		    	abrname.push(word.substring(0,3));
   		    });

			abrname = abrname.join('');
            file.WriteLine('//Generic Looter generated by ' + Player.Name() + ': ' + item.Name());
  			file.WriteLine('@createlist '+ '"'+abrname+'N"');
  			file.WriteLine('@clearlist '+ '"'+abrname +'N"');
			file.WriteLine("@pushlist " + '"'+abrname +'N" '+'"'+ item.Name()+'"');
  			file.WriteLine('@createlist '+ '"'+abrname+'G"');
  			file.WriteLine('@clearlist '+ '"'+abrname +'G"');
			file.WriteLine("@pushlist " + '"'+abrname +'G" '+'"'+ item.Graphic()+'"');
  			file.WriteLine('@createlist '+ '"'+abrname+'C"');
  			file.WriteLine('@clearlist '+ '"'+abrname +'C"');
			file.WriteLine("@pushlist " + '"'+abrname +'C" '+'"'+ item.Color()+'"');
        	file.WriteLine('//---------------------------------------------------');			
		}
	});
        	file.WriteLine('//--- MOVE ITEMS ---');
	items.forEach(function(item)
	{
		 abrname = []
			if (item.Name() != "" ) 
			{
				words = item.Name().replace("'", "").toUpperCase().split(' ');
				    words.forEach(function(word){
				    	abrname.push(word.substring(0,3));
				    });
			abrname = abrname.join('');
            file.WriteLine('//Generic Looter generated by ' + Player.Name() + ': ' + item.Name());
	      	file.WriteLine("if @findtype '"+abrname+'G[0]'+"' '"+ abrname+'C[0]' + "' " + "'corpse'" );
	      	file.WriteLine("    moveitem 'found' 'backpack'" );
    		file.WriteLine('    headmsg "Found ' + item.Name() + '"');
	      	file.WriteLine("    pause 800" );
	      	file.WriteLine("endif" );
        	file.WriteLine('//---------------------------------------------------');			
		}
	});
	
	
	file.Close();
}