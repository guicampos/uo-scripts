// Script for lumberjacking
var wood_storage_key = '0x44A6B3DD'

/**
 * Description
 * @method LumberJack
 * @return 
 */
function LumberJack()
{

    var serializer = "NA";
    var trees = [];
    var treeTileRes = [];
    var tree = null;
    var radius = 1;
    var pushing = true;
    var next = false;

    while (!Player.Dead() && Player.Weight() < Player.MaxWeight() - 60)
    {
        treeTileRes = FindMeTreeTile(radius, trees, next);
        next = false;
        if (treeTileRes == null)
        {
            if (radius <= 100)
            { //possible hazzard
                radius++;
                continue;
            } //if
            else
            {
                Printer(trees);
                return;
            } //else
        } //while

        else
        {
            tree = TreeMaker(serializer, treeTileRes[1], treeTileRes[2], treeTileRes[3], false);
            TextWindow.Print("Tree: " + treeTileRes[1] + " " + treeTileRes[2] + " " + treeTileRes[3]);
            if (trees.length > 0)
            {
                if (IsThere(tree, trees))
                {
                    serializer;
                    pushing = false;
                    next = true;
                }
            }
            if (pushing)
            {
                trees.push(tree);
                Printer(trees);
            }
            else pushing = true;
            if (radius != 1)
            {

                if (trees.length > 0)
                {
                    if (IsBanned(tree, trees))
                    {
                        next = true;
                        continue; //hledame novej
                    }
                }

                if (Walker(tree))
                {
                    radius = 1;
                } //we need to walk

                else
                {

                    serializer;
                    tree.SetIgnore(true);
                    continue;
                }
            }
            if (trees.length > 0)
            {
                if (IsBanned(tree, trees))
                {
                    next = true;
                    continue; //hledame novej

                }
                else TextWindow.Print("No");
            }
            virgin = true;

            while (true)
            {
                journalCheck(1);
                CutTree(tree);
                if (virgin)
                {
                    virgin = false;
                }
                var jour = journalCheck(2);
                if (jour)
                {
                    if (jour.Text() == "That is too far away." || jour.Text() ==
                        "There's not enough wood here to harvest.")
                    {
                        TextWindow.Print("Banning, ignoring, setting next");
                        Orion.Wait(3000);
                        tree.SetIgnore(true);
                        Printer(trees);
                        next = true;
                        break;
                    }
                }

                if (Orion.JournalCount() > 0)
                {
                    for (var i = 0; i < Orion.JournalCount(); i++)
                    {
                        jour = Orion.JournalLine(i);
                        TextWindow.Print(jour.Text());
                    }
                    Printer(trees);
                }
            } //while
        } //else
    } //main while loop
    if (!Player.Dead())
    {
        if (Player.Weight() >= Player.MaxWeight() - 60)
        {
            Orion.UseObject(wood_storage_key);
            if (Orion.WaitForGump(1000))
            {
                var gump0 = Orion.GetGump('last');
                if ((gump0 !== null) && (!gump0.Replayed()) && (gump0.ID() === '0x06ABCE12'))
                {
                    gump0.Select(Orion.CreateGumpHook(37));
                    Orion.Wait(100);
                }
            }
            if (Orion.WaitForGump(1000))
            {
                var gump1 = Orion.GetGump('last');
                if ((gump1 !== null) && (!gump1.Replayed()) && (gump1.ID() === '0x06ABCE12'))
                {
                    gump1.Select(Orion.CreateGumpHook(0));
                    Orion.Wait(100);
                }
            }
            LumberJack()
        }
    }
}

/**
 * Description
 * @method IsBanned
 * @param {} tree
 * @param {} trees
 * @return Literal
 */
function IsBanned(tree, trees)
{

    if (trees.length > 0)
    {
        for (var i = 0; i < trees.length; i++)
        {

            if (tree.GetX() == trees[i].GetX() && tree.GetY() == trees[i].GetY() && trees[i].GetIgnore() ==
                true)
            {
                return true;
            }
        }
    }
    return false;
}

/**
 * Description
 * @method IsThere
 * @param {} tree
 * @param {} trees
 * @return Literal
 */
function IsThere(tree, trees)
{

    if (trees.length > 0)
    {
        for (var i = 0; i < trees.length; i++)
        {

            if (tree.GetX() == trees[i].GetX() && tree.GetY() == trees[i].GetY())
            {

                return true;
            }
        }

    }
    return false;
}

/**
 * Description
 * @method Walker
 * @param {} tree
 * @return 
 */
function Walker(tree)
{

    var treeX = tree.GetX();
    var treeY = tree.GetY();
    var desiredX;
    var desiredY;
    var radiusX = [];
    var radiusY = [];
    var radius = 1;

    for (var x = (treeX - radius); x <= (treeX + radius); x++)
    {

        for (var y = (treeY - radius); y <= (treeY + radius); y++)
        {
            if (x != treeX && y != treeY)
            {
                radiusX.push(x);
                radiusY.push(y);
            }

        }

    }

    desiredX = FindCoord(radiusX, "x");
    desiredY = FindCoord(radiusY, "y");

    if (Orion.WalkTo(desiredX, desiredY, Player.Z(), 0))
    {
        return true;
    }
    else
        return false;

}

/**
 * Description
 * @method FindCoord
 * @param {} coords
 * @param {} axis
 * @return temp
 */
function FindCoord(coords, axis)
{

    var temp;

    if (axis == "x")
    {
        var myCoord = Player.X();
    }
    if (axis == "y")
    {
        var myCoord = Player.Y();
    }

    for (var i = 0; i < coords.length; i++)
    {
        if (i == 0)
            temp = coords[i];
        else
        {
            if (Math.abs(temp - myCoord) > Math.abs(coords[i] - myCoord))
                temp = coords[i];
        }
    }
    return temp;


}

/**
 * Description
 * @method journalCheck
 * @param {} journalClear
 * @return 
 */
function journalCheck(journalClear)
{

    var pattern = "That is too far away.|There's not enough wood here to harvest";

    if (journalClear == 1)
    {
        Orion.ClearJournal(pattern);
        return true;
    }
    else
    {
        return Orion.WaitJournal(pattern, 0, Orion.Now() + 1000, 'my|sys');
    }

}

/**
 * Description
 * @method CutTree
 * @param {} tree
 * @return 
 */
function CutTree(tree)
{

    if (Orion.ValidateTargetTile('tree', tree.GetX(), tree.GetY()))
    {
        Orion.UseType("0x0F49|0x0F45");
        Orion.WaitTargetTile('tree', tree.GetX(), tree.GetY(), tree.GetZ());
        return true;
    }
    else return false;
}

/**
 * Description
 * @method TreeMaker
 * @param {} serial
 * @param {} x
 * @param {} y
 * @param {} z
 * @param {} ignore
 * @return tree
 */
function TreeMaker(serial, x, y, z, ignore)
{
    var tree = new TreeTile();
    tree.SetAll(serial, x, y, z, ignore);
    return tree;
}

/**
 * Description
 * @method FindMeTreeTile
 * @param {} dist
 * @param {} trees
 * @param {} next
 * @return Literal
 */
function FindMeTreeTile(dist, trees, next)
{
    var tiles;
    for (var x = -dist; x <= dist; x++)
    {
        for (var y = -dist; y <= dist; y++)
        {
            if (x == 0 && y == 0) continue;
            else
            {
                if (Orion.ValidateTargetTileRelative('tree', x, y))
                {
                    if (trees.length > 0)
                    {
                        for (var i = 0; i < trees.length; i++)
                        {
                            if ((Player.X() + x) == trees[i].GetX() && (Player.Y() + y) == trees[i].GetY() &&
                                trees[i].GetIgnore() == true)
                            {
                                var banned = true;
                                break;
                            }
                        }
                    }
                    if (banned)
                    {
                        banned = false;
                        continue;
                    }
                    else
                    {
                        if (!next)
                        {
                            tiles = Orion.GetTiles('tree', (Player.X() + x), (Player.Y() + y))
                            return [true, (Player.X() + x), (Player.Y() + y), tiles[0].Z()];
                        }
                        else next = false;
                    }
                }
            }
        }
    }
    return null;
}

/**
 * Description
 * @method Printer
 * @param {} trees
 * @return 
 */
function Printer(trees)
{
    if (trees.length > 0)
    {
        for (var i = 0; i < trees.length; i++)
        {
            TextWindow.Print(trees[i].GetAll());
        }
    }
}

/**
 * Description
 * @method TreeTile
 * @param {} _private
 * @return 
 */
function TreeTile(_private)
{
    this.serial
    this.x
    this.y
    this.z
    this.ignore
    this.ignoreTime

    /**
     * Description
     * @method SetAll
     * @param {} serial
     * @param {} x
     * @param {} y
     * @param {} z
     * @param {} ignore
     * @return 
     */
    this.SetAll = function(serial, x, y, z, ignore)
    {
        this.serial = serial;
        this.x = x;
        this.y = y;
        this.z = z;
        this.SetIgnore(ignore);
    }
    /**
     * Description
     * @method SetCoords
     * @param {} X
     * @param {} Y
     * @param {} Z
     * @return 
     */
    this.SetCoords = function(X, Y, Z)
    {
        this.x = X;
        this.y = Y;
        this.z = Z;
    }
    /**
     * Description
     * @method SetSer
     * @param {} serial
     * @return 
     */
    this.SetSer = function(serial)
    {
        this.serial = serial;
    }
    /**
     * Description
     * @method SetIgnore
     * @param {} value
     * @return 
     */
    this.SetIgnore = function(value)
    {
        this.ignore = value;
        if (value == true) this.ignoreTime = Orion.Now();
        else this.ignoreTime = null;
    }
    /**
     * Description
     * @method GetIgnoreTime
     * @return MemberExpression
     */
    this.GetIgnoreTime = function()
    {
        return this.ignoreTime;
    }

    /**
     * Description
     * @method GetX
     * @return MemberExpression
     */
    this.GetX = function()
    {
        return this.x;
    }
    /**
     * Description
     * @method GetY
     * @return MemberExpression
     */
    this.GetY = function()
    {
        return this.y;
    }
    /**
     * Description
     * @method GetZ
     * @return MemberExpression
     */
    this.GetZ = function()
    {
        return this.z;
    }
    /**
     * Description
     * @method GetSer
     * @return MemberExpression
     */
    this.GetSer = function()
    {
        return this.serial;
    }
    /**
     * Description
     * @method GetIgnore
     * @return MemberExpression
     */
    this.GetIgnore = function()
    {
        return this.ignore;
    }
    /**
     * Description
     * @method GetAll
     * @return ArrayExpression
     */
    this.GetAll = function()
    {
        return [this.serial, this.x, this.y, this.z, this.ignore, this.ignoreTime];
    }

}
