// - SCRIPT START. YOU CAN EDIT THIS
var system_name = "Advanced Combat System with Voice Commands"
var system_version = "v2.1"
var combatMode_default = 'automode'; // default when reseting
var min_jewelry_skill = 13; // >= +10 mace fighting for example
var qty_jewelry_skill = 2; // how many skills to grab?  swords+tactics = 2; swords+tactics+anatomy = 3, so on
var hits_limit = 85 //this is%, not absolute value
var pulse_time = 150;
var bandagedelay = 4000;
// Configure all here! you can edit but be careful. Try to edit only defaults values or delay numbers.
features = [
{
    'name': 'cmode',
    'command': '.cm',
    'defaultv': 'on',
    'type': 'combatmode',
    'ability': 'Secondary',
    'range': 1,
    'dress': 'championset'
},
{
    'name': 'smode',
    'command': '.sm',
    'defaultv': 'on',
    'type': 'combatmode',
    'ability': 'Primary',
    'range': 1,
    'dress': 'championset'
},
{
    'name': 'automode',
    'command': '.am',
    'defaultv': 'on',
    'type': 'combatmode',
    'range': 1,
},
{
    'name': 'rmode',
    'command': '.rm',
    'defaultv': 'on',
    'type': 'combatmode',
    'ability': 'Primary',
    'range': 12,
    'dress': 'rangedset'
},
{
    'name': 'Consecrate Weapon',
    'command': '.acw',
    'defaultv': 'on',
    'type': 'auxspells',
    'spellname': 'Consecrate Weapon',
    'mana': '8',
    'cooldown': 7000,
    'recovery': 500,
    'has_target': null,
    'func': "common_cast"
},
{
    'name': 'Divine Fury',
    'command': '.adf',
    'defaultv': 'on',
    'type': 'auxspells',
    'spellname': 'Divine Fury',
    'mana': '12',
    'cooldown': 17000,
    'recovery': 500,
    'has_target': null,
    'func': 'common_cast'
},
{
    'name': 'Evasion',
    'command': '.aev',
    'defaultv': 'on',
    'type': 'auxspells',
    'spellname': 'Evasion',
    'mana': '12',
    'cooldown': 22000,
    'recovery': 500,
    'has_target': null,
    'func': 'common_cast'
},
{
    'name': 'Counter Attack',
    'command': '.aca',
    'defaultv': 'on',
    'type': 'auxspells',
    'spellname': 'Counter Attack',
    'mana': '12',
    'cooldown': 8000,
    'recovery': 500,
    'has_target': null,
    'func': 'common_cast'
},
{
    'name': 'autoLooter',
    'command': '.atl',
    'defaultv': 'on',
    'type': 'automation'
},
{
    'name': 'Wither',
    'command': '.awt',
    'defaultv': 'off',
    'type': 'auxspells',
    'spellname': 'Wither',
    'mana': '23',
    'cooldown': 800,
    'recovery': 500,
    'has_target': null,
    'func': 'common_cast'
},
{
    'name': 'autoBandageSelf',
    'command': '.abs',
    'defaultv': 'on',
    'type': 'automation'
},
{
    'name': 'getGold',
    'command': '.gg',
    'defaultv': 'off',
    'func': 'getGold',
    'type': 'automation'
},
{
    'name': 'auto Honor',
    'command': '.aho',
    'defaultv': 'off',
    'type': 'automation',
    'func': 'autoHonor'
},
{
    'name': 'Triple Slash',
    'command': '.tps',
    'defaultv': 'off',
    'type': 'automation'
},
{
    'name': 'reload',
    'command': '.reload',
    'defaultv': 'off',
    'func': 'reload_globals',
    'type': 'setup'
},
{
    'name': 'openpaperdoll',
    'command': '.ppd',
    'defaultv': 'on',
    'func': 'open_paperdoll',
    'type': 'automation',
    'cooldown': 5000,
    'recovery': 0,
    'has_target': null
},
{
    'name': 'help',
    'command': '.help',
    'defaultv': 'off',
    'func': 'showhelp',
    'type': 'setup'
},
{
    'name': 'status',
    'command': '.status',
    'defaultv': 'off',
    'func': 'showStatusGump',
    'type': 'setup'
},
];
skill_list = 'Alchemy|Anatomy|Animal Lore|Animal Taming|Archery|Arms Lore|Begging|Blacksmithy|Bowcraft & Fletching|Bushido|Camping|Carpentry|Cartography|Chivalry|Cooking|Detecting Hidden|Discordance|Evaluating Intelligence|Fencing|Fishing|Focus|Forensic Evaluation|Glassblowing|Healing|Healing|Herding|Hiding|Imbuing|Inscription|Item Identification|Lockpicking|Lumberjacking|Mace Fighting|Magery|Masonry|Meditation|Mining|Musicianship|Mysticism|Necromancy|Ninjitsu|Parrying|Peacemaking|Poisoning|Provocation|Remove Trap|Resisting Spells|Snooping|Spellweaving|Spirit Speak|Stealing|Stealth|Swordsmanship|Tactics|Tailoring|Taste Identification|Throwing|Tinkering|Tracking|Veterinary|Wrestling';

adjective_list = ['Saviour of Sosaria', 'Love of My Life', 'Friend', 'My Eye Candy', Player.Name(), ];

function Autostart()
{
  
   Orion.Exec('handleFeatures', true);
   Orion.Exec('handleWorldSaves', true);
   Orion.Exec('ShowDPS', true);

}

// -------------- SCRIPT START - DO NOT EDIT

// Handlers list

handlers_list = [ 
        "handleWorldSaves", 
        "handleFeatures",
        "autoBandageSelf", 
        "handleCombatMode",
        "handleAuxSpells", 
        "autoHonor", 
        "autoLooter",
        "handleFunctions",
        "specialAttack_handler",
        "ShowDPS",
        ];

// ===Globals ============================

var honoredList = Orion.GetIgnoreList('honoredList');
featuresIndexed = {}
for (var i = 0, len = features.length; i < len; i++)
{
    featuresIndexed[features[i].name] = features[i];
}

// ====================================
function init_acswvc_system()
{
	 greeting = "Hello ";
	 greeting_back = "";
    if (!Shared.GetVar('initialized') || Shared.GetVar('initialized') != 'yes')
    { // reset system and iinitialize all default states
        Orion.Print(1989, 'System Starting');
        Shared.ClearVars();
        for (var i = 0; i < features.length; i++)
        {
            Shared.AddVar(features[i].name, features[i].defaultv);
            Shared.AddVar('initialized', 'yes');
        }
    }
    else
    { // resuming from the last state
	    greeting_back ="and welcome back ";
    }

    Orion.Print(1989, greeting + greeting_back + adjective_list[Orion.Random(0,adjective_list.length)]+ '!');
    // Set timers if not exists
    if (!Orion.TimerExists('abilityTimer'))
    {
        Orion.SetTimer('abilityTimer', 0)
    }
    if (!Orion.TimerExists('openPaperdollTimer'))
    {
        Orion.SetTimer('openPaperdollTimer', 0)
    }
    if (!Orion.TimerExists('honoredListCleanup'))
    {
        Orion.SetTimer('honoredListCleanup', 0);
    }
    if (!Orion.TimerExists('recoveryTimer'))
    {
        Orion.SetTimer('recoveryTimer', 0);
    }
    if (!Orion.TimerExists('autoBandageSelf'))
    {
        Orion.SetTimer('autoBandageSelf', 0);
    }    

    if (!Shared.GetVar('currentRecoveryDelay'))
    {
        Shared.AddVar("currentRecoveryDelay", 0);
    }
    Orion.SetGlobal('enemies_around', 0);

}



function handleCombatMode()
{
    while (true)
    {
		currentMode = Shared.GetVar('combatmode') ? Shared.GetVar('combatmode') : combatMode_default;
    	enemies_around = findEnemies(featuresIndexed[currentMode].range + 1 , "live|ignoreself|mobile", "gray|criminal|orange|red");

        if (currentMode == 'automode')
        {

			if (enemies_around.length > 1) 
			{
				currentMode = 'cmode';
			}
			else 
			{
				currentMode = 'smode';
			}
        }
        
        enemy = acquireTarget(featuresIndexed[currentMode].range);
        Orion.Wait(15);
        Orion.Dress(featuresIndexed[currentMode].dress);
        if (Orion.ObjectExists(enemy))
        {
            attackTarget(featuresIndexed[currentMode].ability);
        }
        Orion.Wait(pulse_time);
    }
}

function attackTarget(ability)
{
    if (Orion.Timer('abilityTimer') >= 600 && Orion.Timer('recoveryTimer') >= Shared.GetVar("currentRecoveryDelay"))
    {
        if ((ability == 'Secondary' || ability == 'Primary'))
        {
            if (!Orion.AbilityStatus(ability))
            {
                Orion.UseAbility(ability);
                Orion.SetTimer('abilityTimer', 0);
                Orion.SetTimer('recoveryTimer', 0);
                Shared.GetVar("currentRecoveryDelay", 300);
            }
        }
        else
        {
            if (!Orion.SpellStatus(ability))
            {
                Orion.Cast(ability)
                Orion.SetTimer('abilityTimer', 0);
                Orion.SetTimer('recoveryTimer', 0);
                Shared.GetVar("currentRecoveryDelay", 300);
            }
        }
        Orion.AddDisplayTimer('abilityTimer', 600, 'LeftBottom', 'Line|Bar|Vertical', 'abilityTimer', 120, 0, '1990', -
            1, '0xFD')
    }
    Orion.Attack(Orion.GetSerial('closest_enemy'));
    Orion.Wait(pulse_time);
}

function common_cast(spellname, mana, cooldown, recovery, target, position)
{

    if (Player.Mana() >= mana && Orion.Timer(spellname) >= cooldown && Orion.Timer('recoveryTimer') >= Shared.GetVar(
            "currentRecoveryDelay"))
    {
        //				Orion.Print(functionname+'('+spelltocast+','+ mana+','+ cooldown+',' +recovery+','+ target+')');
        if (!target)
        {
            if (spellname == 'Counter Attack' && Orion.Timer('evasionTimer') <= 10000)
            {
                Orion.Wait(pulse_time);
                return false;
            }
            Orion.Cast(spellname);
        }
        else
        {
            Orion.CastTarget(spellname, target);
        }
        Orion.SetTimer(spellname, 0);
        Orion.SetTimer('recoveryTimer', 0);
        Shared.AddVar("currentRecoveryDelay", recovery);
        Orion.AddDisplayTimer(spellname, cooldown, 'Bottom', 'Line|Bar', spellname.replace(' ', '\r\n'), (position *
            65), 0)
        Orion.AddDisplayTimer('currentRecoveryDelay', recovery, 'LeftBottom', 'Line|Bar', 'recovery_delay', 0, 0, '87',
            -1, '0xFD')
        return true;
    }
    return false;
}


function specialAttack_handler(specialAttack_name)
{
	var specialAttack_name = specialAttack_name ? specialAttack_name : 'Triple Slash';
	while(true)
	{
        if (Shared.GetVar(specialAttack_name) == 'off')
        {
            Orion.Wait(pulse_time);
            continue;
        }
        else
        {
    	    specialAttack(specialAttack_name);
	        Orion.Wait(400);        
        }
        
	}
}

function specialAttack(specialAttack)
{

	var armed = false;
    var currentMode = Shared.GetVar('combatmode') ? Shared.GetVar('combatmode') : combatMode_default;


       
	switch (specialAttack) {
	  case 'Triple Slash':
	    specialAttack_type = 'Attack'; // triple slash gump text
	    reagent_graph = '0x0F86'; // Madrake Root
	    reagent_qty = 1;
	    mana = 50;
	    stamina = 50;
	    break;
	  case 'Shield Of Spikes':
	    specialAttack_type = 'Defense'; // shield of spikes gump text
	    reagent_graph = '0x0F8A';
	    reagent_qty = 3;
	    mana = 0;
	    stamina = 20;
	    break;
	  default:
	    Orion.Print('Unknown Special Attack type.', 1990);
	    return false;
	}
	
	Orion.WaitForGump(500);
	var specialAttack_gump = GetGump(specialAttack_type);
    
	// If the special attack is not opened, then force requiping the equipment
	if (! specialAttack_gump || specialAttack_gump == null || specialAttack_gump == undefined )
	{
		var dress_name = featuresIndexed[currentMode].dress;
   	    Orion.Print(specialAttack + ' gump not found. Reequiping your weapons. ( Dressing ' +dress_name+')');
		Orion.Unequip('RightHand');
		Orion.Wait(pulse_time*4)
		Orion.Unequip('LeftHand');
		Orion.Wait(pulse_time*4)
		Orion.Dress(dress_name);
		Orion.WaitForGump();
	}

	var specialAttack_gump = GetGump(specialAttack_type);
	if (! specialAttack_gump || specialAttack_gump == null || specialAttack_gump == undefined )
	{
   	    Orion.Print(specialAttack + ' gump not found. Cannot continue');
   	    throw false;
	}

	if (specialAttack_gump.GumppicList().length <= 0) return false;
	
	for (var i = 0; i < specialAttack_gump.GumppicList().length; i++)
	{
		if (Orion.Contains(specialAttack_gump.GumppicList()[i], "hue=33"))
		{
			armed = true;
			break;
		}
	}

	function validatePrerequisites()
	{
		var regs = Orion.FindType(reagent_graph, '0x0000', 'backpack', 'item|fast');

		if (regs.length < reagent_qty)
		{
			Orion.Print('You need Reagets on you backpack for Auto '+specialAttack);
			return false;
		}
		
		if (Player.Mana() >= mana && Player.Stam() >= stamina && regs.length >= reagent_qty)
		{
			return true;
		}
		
		return false;
	}
	
	// nested function to rearm.
	function rearm(specialAttack_gump)
	{
		specialAttack_gump.Select(Orion.CreateGumpHook(1000));
		Orion.Print(specialAttack + ' reloaded');
	}
	
	
	if (armed == true) 
	{
		null; // Orion.Print('special attack is ARMED');
	}
	
    if (armed == false) 
    {
	    if (validatePrerequisites()) 
	    {
	    	rearm(specialAttack_gump);
	    }
    }

}


function open_paperdoll()
{
    while (true)
    {
        if (Orion.Timer('openPaperdoll') >= 3000)
        {
            Orion.OpenPaperdoll("self");
            Orion.SetTimer('openPaperdoll', 0);
        }
        Orion.Wait(pulse_time);
    }

}

function handleAuxSpells()
{
    while (true)
    {
        for (var i = 0; i < features.length; i++)
        {
            if ((Shared.GetVar(features[i].spellname) == 'off'))
            {
                continue;
            }
            if (!features[i].type || (features[i].type && features[i].type != 'auxspells'))
            {
                continue;
            }
            	
           
            spelltocast = features[i].spellname;
            mana = features[i].mana;
            cooldown = features[i].cooldown;
            recovery = features[i].recovery;
            has_target = features[i].has_target;
            target = null;
            if (has_target)
            {
                target = Orion.GetSerial('closest_enemy');
            }
            if (!Orion.TimerExists(spelltocast))
            {
                Orion.SetTimer(spelltocast, cooldown + 1);
            }
            if (features[i].func && this[features[i].func] != undefined)
            {
                this[features[i].func](spelltocast, mana, cooldown, recovery, target, i);
                Orion.Wait(10);
            }
            else
            {
                Orion.Print(1989, 'WARNING: function ' + features[i].func + ' for spell ' + spelltocast + ', feature ' +
                    features[i].name + ' is uniplemented')
                continue;
            }
            Orion.Wait(10);
        }
        Orion.Wait(pulse_time);
    }
}

function autoBandageSelf()
{

    while (true)
    {
        if (Shared.GetVar('autoBandageSelf') == 'off')
        {
	         Orion.Wait(pulse_time);
            return false;
        }

        if (Orion.Timer('autoBandageSelf') >= bandagedelay && !Player.Dead() && (Player.Hits('%') < hits_limit || Player.Poisoned()))
        {
            Orion.BandageSelf();
            Orion.SetTimer('autoBandageSelf', 0);
        }        

        Orion.Wait(pulse_time);
    }
}

function handleFeatures()
{
    while (true)
    {
  		enemies_around = findEnemies(10, "live|ignoreself|mobile", "gray|criminal|orange|red").length;
         if ( enemies_around <= 0 )
         {
         	Orion.PauseScript('handleAuxSpells');
         }
         else 
         {
	         Orion.ResumeScript('handleAuxSpells');
         }
            
        for (var i = 0; i < features.length; i++)
        {
            if (Orion.InJournal(features[i].command, 'self'))
            {
                Orion.ClearJournal();
                if (features[i].type == 'combatmode')
                {
		              Shared.RemoveVar(features[i].type);
                    Shared.AddVar(features[i].type, features[i].name);
                    Orion.Print(features[i].name + ' enabled.');
                }
                else
                {
                    feature_status = Shared.GetVar(features[i].name);
                    new_status = feature_status == 'on' ? 'off' : 'on';
					Shared.RemoveVar(features[i].name);
                    Shared.AddVar(features[i].name, new_status);
                    Orion.Print(features[i].name + ' is now ' + new_status);
                    Orion.Exec("handleFunctions", true, features[i].func);
                }
            }
        }
        Orion.Wait(pulse_time);
    }
}

function handleFunctions(func)
{
    if (func && func != undefined)
    {
        Orion.Wait(50);
        this[func]()
        Orion.Wait(50);
    }
}



function getGold()
{
     Orion.FindType('0x0EED', 'any', 'ground', 'item',20).forEach(function(gold){
		     Orion.UseObject(gold);
		     Orion.Wait(50);
     });
}

function autoLooter()
{

    while (true)
    {
        if (Shared.GetVar('autoLooter') == 'off')
        {
            Orion.Wait(pulse_time);
            return false;
        }
        Orion.FindType('0x2006|0x2DF3', 'any', 'ground')
        .forEach(function(corpse_nearby)
        {
            Orion.UseObject(corpse_nearby);
            Orion.Wait(400);
            Orion.Ignore(corpse_nearby);

            Orion.FindTypeEx('0x108a|0x1f09|0x1086|0x1f06', 'any', corpse_nearby)
            .forEach(function(jewelry_in_corpse)
            {
                var properties_found = []
                properties_found = PullProperty(jewelry_in_corpse, skill_list);
                if (properties_found && properties_found.length >= qty_jewelry_skill)
                {
                    Orion.MoveItem(jewelry_in_corpse.Serial(), 1, 'backpack');
                    Orion.Wait(600);
                    Orion.Print('2226', '?' + jewelry_in_corpse.Name() + ' found with ' + properties_found.length +
                        ' skill' + (properties_found.length > 1 ? 's' : '') + ' >=' + min_jewelry_skill);
                    for (var j = 0; j < properties_found.length; j++)
                    {
                        Orion.Print('2226', '   ' + properties_found[j][1] + ' - ' + properties_found[j][2]);
                    }
                    Orion.Say("[e oh");
                }
            });

            
            // Others by graphic and color. Always place the correspoding color in the same position as the graphic.
//            others_in_corpse_graph = ['0x0C6A', '0x1CED', '0x21FE', '0x18E5', '0x0F3B', '0x187E', '0x0D16', '0x0E27', '0x0F7E', '0x10E7', ] ;
//            others_in_corpse_color  = ['0x04EB', '0x056C', '0x0000', '0x0000', '0x0000', '0x0000', '0x056C', '0x0003', '0x0000', '0x0000', ];
 //           for (var i = 0; i < others_in_corpse_graph.length; i++)
 //           {
 //                Orion.MoveItemType(others_in_corpse_graph[i], others_in_corpse_color[i], corpse_nearby, 0, 'backpack');
 //                Orion.Wait(600);
 //           }
       });

        Orion.Wait(pulse_time);
    }
}

function PullProperty(item, skill)
{
    if (item)
    {
        searchResult = []
        var itemPropLines = item.Properties().split(/\n|\r/);
        for (var j = 0; j < itemPropLines.length; j++)
        {
            var regex = "(" + skill + ")" + "\\s+\\+(\\d+)";
            var search = itemPropLines[j].match(regex);
            if (search && search != undefined && search[2] >= min_jewelry_skill)
            {
                searchResult.push(search);
            }
        }
        return searchResult;
    }
}

function system_initialization()
{
    if (Orion.ScriptRunning('handleCombatMode') == 0)
    { // script is not running. Execute all.
        init_acswvc_system();
        
        for (var i = 0; i < handlers_list.length; i++)
        {
	        Orion.Exec(handlers_list[i]);
	        Orion.Wait(10);
        }
    }
    else if (Orion.ScriptRunning('handleCombatMode') > 0)
    { // script is running. Suspend all
        suspendScripts();
    }
    else if (Orion.ScriptRunning('handleCombatMode') < 0)
    { // < 0. System is suspended. resume all
        resumeScripts();
    }
}

function suspendScripts()
{
    Orion.ClearJournal();
    Orion.PauseScript("all", 'handleFunctions|system_initialization|handleWorldSaves|ShowDPS');
    Orion.Wait(10);
    Orion.Print('All scripts suspended.');
}

function resumeScripts()
{
    Orion.ClearJournal();
    Orion.ResumeScript("all");
    Orion.Wait(10);
    Orion.Print('Resuming all scripts.');
}

function handleWorldSaves()
{
    while (true)
    {
        if (Orion.InJournal('The world is saving, please wait.', 'system'))
        {
            Orion.Print(1990, 'Pausing all scrips for world save');
            Orion.AddDisplayTimer('worldSaveTimer', 60000, 'AboveChar', 'circle|bar', 'WorldSave');
            suspendScripts();
            Orion.Wait(50);
            Orion.ClearJournal();
        }
         if (Orion.WaitJournal('World save complete.', Orion.Now(), Orion.Now() + 60000, 'system'))
         {
             Orion.Wait(pulse_time);
             Orion.RemoveDisplayTimer('worldSaveTimer');
             Orion.ClearJournal();
             resumeScripts();
         }
        Orion.Wait(pulse_time);
    }
}

function haltAllScripts()
{
     for (var i = 0; i < handlers_list.length; i++)
     {
        Orion.PauseScript(handlers_list[i]);
        Orion.Wait(10);
        Orion.Terminate(handlers_list[i]);
        Orion.Wait(10);
     }
}
function reload_globals()
{
    Orion.Print('OK, reloading');
    haltAllScripts()
    Orion.ClearTimers();
    Shared.ClearVars();
    Orion.ClearIgnoreList('honoredList');
    Orion.ClearEnemyList();
    Orion.ClearFakeMapObjects();
    Orion.Wait(pulse_time);
    system_initialization();
    return true;
}

function showStatusGump()
{
    var gump = Orion.CreateCustomGump(1550);
    gump.Clear();

    gump.AddResizepic(0, 0, '13BE', 1250, 250 + (features.length * 13));
    var step = 25;
    var stepx = 25;
    var x = 7;
    var y = 4;
    gump.AddText(x, y, 1990, "Status for " + system_name + ' ' + system_version);
    y += step;
    gump.AddText(x, y, "1718", "Welcome, {name}");
    y += step;
    gump.AddText(x, y, "1718", "Current Combat Mode: ");
    gump.AddText(x+140, y, "1426", "["+Shared.GetVar("combatmode")+"]");
    y += step;
	gump.AddText(x, y, "1718", "Features Statuses: ");
	y += step;
    sortedFeatures = features.sort(GetSortOrder("name"));
    for (var i = 0; i < sortedFeatures.length; i++)
    {
        if (sortedFeatures[i].type != 'combatmode') {
	        gump.AddText(25, y, (Shared.GetVar(sortedFeatures[i].name) == 'on' ? 1426 : 1653), "[" + Shared.GetVar(sortedFeatures[i]
            .name) + "] ");
        gump.AddText(60, y, 1350, sortedFeatures[i].name );
        
        gump.AddText(180, y, 1291, JSON.stringify(sortedFeatures[i]));
        y += step;
        stepx += stepx;
        }

    }
    // Commit gump changes and update it in client
    gump.Update();
}

function autoHealPet()
{
    var petHealingTimer = 2500;
    if (!Orion.ObjectExists("mypet"))
    {
        Orion.Print("Target your mount");
        Orion.WaitForAddObject("mypet");
        Orion.Wait(10);
    }
    petObject = Orion.FindObject(Orion.GetSerial("mypet"));
    var Timer, Msg = "You finish applying bandages.";
    while (!Player.Dead() && Orion.Count('0x0E21'))
    {
        //calculating pet hp percentages
        var myPetHpPercentage = petObject.Hits() * 100 / petObject.MaxHits();
        //CheckHp percentages start heal if one of the pets have lower than 95% hp
        if (myPetHpPercentage < 98)
        {
            //If petOne has lower or eqaul hp to petTwo heal petOne, else heal petTwo
            Orion.Print('-1', 'Attempting to heal your pet:' + petObject.Name());
            //Orion.UseObject('bandage');
            var bandageType = '0x0E21';
            Orion.UseType(bandageType);
            Orion.WaitTargetObject(petObject.Serial());
            Timer = Orion.Now() + petHealingTimer;
            while (Orion.InJournal(Msg) || Orion.Now() < Timer)
            {
                Orion.Wait(10);
                continue;
            }
        }
        else
        {
            Orion.Wait(10);
        }
    }
}

function findEnemies(searchrange, findflag, notoriety)
{
    if (!searchrange)
    {
        searchrange = 10;
    }
    var mobs = Orion.FindType(any, any, 'ground', findflag, searchrange, notoriety);
    return mobs;
}

function acquireTarget(range)
{

    closest_enemy = findEnemies(range, "live|ignoreself|mobile|fast|near", "gray|criminal|orange|red");
    if (closest_enemy && Orion.ObjectExists(closest_enemy))
    {
        Orion.AddObject('closest_enemy', closest_enemy);
        return closest_enemy;
    }
    else
    {
        Orion.RemoveObject('closest_enemy');
    }
    Orion.Wait(pulse_time);
}

function autoHonor()
{
    if (!honoredList)
    {
        var honoredList = Orion.GetIgnoreList('honoredList');
    }
    if (!Orion.TimerExists('honoredListCleanup'))
    {
        Orion.SetTimer('honoredListCleanup', 0);
    }
    while (true)
    {
        if (Shared.GetVar('auto Honor') == 'off')
        {
            Orion.Wait(pulse_time);
            return false;
        }
        if (Orion.Timer("honoredListCleanup") > 60000)
        {
            Orion.ClearIgnoreList('honoredList');
            Orion.AddDisplayTimer('honoredListCleanup', 60000, 'LeftBottom', 'Line|Bar|Vertical', 'honor cleanup', 75,
                0, '87', -1, '0xFD')
            Orion.SetTimer("honoredListCleanup", 0);
        }
        searchHonor();
        Orion.Wait(pulse_time);
    }
}


function listHonored()
{
    if (!honoredList)
    {
        var honoredList = Orion.GetIgnoreList('honoredList');
    }
    list_items = honoredList.Items()
    resultlist = []
    for (i = 0; i < list_items.length; i++)
    {
        if (list_items[i] || list_items[i] != null || list_items[i] != undefined)
        {
            resultlist.push(list_items[i].Serial())
        }
    }
    return resultlist;
}

function searchHonor()
{
    var targets = Orion.FindTypeEx(any, any, 'ground', "live|ignoreself|mobile|inlos", 6, "gray|criminal|orange|red");
    honoredList = listHonored()
    for (i = 0; i < targets.length; i++)
    {
        if (targets[i].Hits('%') <= 0)
        {
            Orion.GetStatus(targets[i].Serial());
            Orion.Wait(pulse_time);
        }
        if (honoredList.contains(targets[i].Serial()) != true && targets[i].Hits('%') == 100 && Orion.InLOS(targets[i]
                .Serial()))
        {
            applyHonor(targets[i]);
        }
    }
}

function applyHonor(target)
{
    if (!target || target == undefined)
    {
        return false;
    }
    if (!honoredList)
    {
        var honoredList = Orion.GetIgnoreList('honoredList');
    }
    Orion.InvokeVirtue('Honor');
    Orion.WaitTargetObject(target.Serial());
    list_items = honoredList.Items()
    list_items.push(new IgnoreListItem('any', 'any', target.Serial(), target.Name()))
    honoredList.SetItems(list_items);
    Orion.AddHighlightCharacter(target.Serial(), '0x513');
    Orion.UpdateIgnoreList(honoredList);
    Orion.Wait(600);
}


function ShowDPS() {
    var dps = 0
    var highestdps = 0
    var lastMessage = Orion.LastJournalMessage();
    
    while (true) {

        Orion.Wait(pulse_time);
        lastMessage = Orion.LastJournalMessage();
        var pastMessage = lastMessage
        dps = 0
        while (pastMessage != null && pastMessage.Timer() > Orion.Now() - 1250) {
            if (pastMessage.Serial() == '0xFFFFFFFF' &&
                Orion.Contains(pastMessage.Text(), 'damageecho') &&
                !Orion.Contains(pastMessage.Text(), Player.Serial())) {
                var outcome = pastMessage.Text().match(/^damageecho:\s\w*=\w*\s\w*=(\d*)/i)
                dps += parseInt(outcome[1])
            }

            if (dps > highestdps) {
                highestdps = dps
            }
            pastMessage = pastMessage.PrevMessage()

        }

        DPSGump(dps, highestdps)
    }
}


function DPSGump(dps, highestdps) {
    var gumpId = 61
    gump = Orion.CreateCustomGump(gumpId);
    gump.SetNoClose(true);
    gump.Clear();
    gump.AddHtmlGump(1, 0, 0, 160, 70, '0x1400', 0, 0);
    gump.Select('htmlgump', 1);
    gump.AddText(10, 10, '0x0035', 'Current DPS -- ' + dps);
    gump.AddText(10, 30, '0x0035', 'Highest DPS -- ' + highestdps);
    gump.Select('gump');
    gump.Update();
}


function generateRandom(min, max) {

    // find diff
    var difference = max - min;

    // generate random number 
    var rand = Math.random();

    // multiply with difference 
    rand = Math.floor( rand * difference);

    // add with min value 
    rand = rand + min;

    return rand;
}


function GetGump(text, index)
{
    if (index == undefined || index == null) index = 0;

    var count = Orion.GumpCount();

    if (!count)
    {
        return null;
    }

    for (var i = count - 1; i >= 0; i--)
    {
        var gump = Orion.GetGump(i);
        if (gump && Orion.GumpExists("generic", gump.Serial(), gump.ID()))
        {

            for (var j = 0; j < gump.TextList().length; j++)
            {
                if (Orion.Contains(gump.Text(j), text))
                {
                    return gump;
                }
            }
        }

    }

    return null;
}


Array.prototype.contains = function (obj)
{
    var i = this.length;
    while (i--)
    {
        if (this[i] === obj)
        {
            return true;
        }
    }
    return false;
}

function createArr(x, y)
{
    var arr = new Array(x);
    for (var i = 0; i < x; i++)
    {
        arr[i] = new Array(y);
    }
    return arr;
}

function GetSortOrder(prop) {    
    return function(a, b) {    
        if (a[prop].toUpperCase() > b[prop].toUpperCase()) {    
            return 1;    
        } else if (a[prop].toUpperCase() < b[prop].toUpperCase()) {    
            return -1;    
        }    
        return 0;    
    }    
}  

function activeAllKeys()
{
	// Order by most used/needed. Don't worry if you don't have a key. The script will ignore it.
    storageKeyArray = [
    {
        'graphic': "0x2FEA",
        'name': "Gem Storage",
        'color': "0x0482"
    },
    {
        'graphic': "0x0FBE",
        'name': "Scribe's Tome",
        'color': "0x0000"
    },
    {
        'graphic': "0x18DE",
        'name': "Reagent Keys",
        'color': "0x0021"
    },
    {
        'graphic': "0x14EE",
        'name': "Treasure Hunter's Storage",
        'color': "0x0745"
    },
    {
        'graphic': "0x2259",
        'name': "Ultimate Power Scroll Book",
        'color': "0x0481"
    },
    {
        'graphic': "0x1EBA",
        'name': "Runic Tool Box",
        'color': "0x0041"
    },
    {
        'graphic': "0x1EBB",
        'name': "Tool Box",
        'color': "0x002D"
    },
    {
        'graphic': "0x09A8",
        'name': "Jewelry Box",
        'color': "0x0000"
    },
    {
        'graphic': "0x1BD9",
        'name': "Wood Storage",
        'color': "0x0058"
    },
    {
        'graphic': "0x177C",
        'name': "Stone Storage",
        'color': "0x0489"
    },
    {
        'graphic': "0x1BE8",
        'name': "Ingot Keys",
        'color': "0x0014"
    },
    {
        'graphic': "0x0F9D",
        'name': "Tailor Store",
        'color': "0x0044"
    },
    {
        'graphic': "0x185E",
        'name': "Potion Storage",
        'color': "0x0030"
    }, 
/*    {
        'graphic': "0x11C6",
        'name': "Evo Key",
        'color': "0x0501"
    },
*/
    
];

    for (i = 0; i < storageKeyArray.length; i++)
    {
        keyinfo = storageKeyArray[i];
        keystorage = Orion.FindType(keyinfo.graphic, keyinfo.color, 'backpack', 'item|fast');
        if (keystorage && keystorage != undefined)
        {
            Orion.RequestContextMenu(keystorage);
            Orion.WaitContextMenuID(keystorage, 2);
            Orion.CharPrint(keystorage, -1, keyinfo.name);
            if (Orion.WaitForGump(1000))
            {
                var gump0 = Orion.GetGump('last');
                if ((gump0 !== null) && (!gump0.Replayed()) && (gump0.ID() === '0x06ABCE12'))
                {
                    gump0.Select(Orion.CreateGumpHook(0));
                }
            }
            Orion.Wait(300);
        }
    }
     Orion.CancelContextMenu();
}


function statusBar(showDetails)
{
	// Create new custom gump with serial 15
	var gump = Orion.CreateCustomGump(15);
	
	// This gump will be no closible by a right mouse click
	gump.SetNoClose(false);
	
	// Clear gump cpntents (for rebuilds)
	gump.Clear();
    var sortedFeatures = features.sort(GetSortOrder("name")).filter(function(feature){
    	if (!Orion.Contains(feature.type, 'combatmode|setup'))
    	{
    		return feature;
    	}
    });
	// Set callback function
	gump.SetCallback('statusBar_callbacks');

	// Main background

	gump.AddResizepic(0, 0, '3501', 230, 30);
	gump.AddResizepic(230, 0, '3501', 230, 30);
	gump.AddResizepic(460, 0, '3501', 125, 30);



	var itemSerial = 1;
	x = 10;
	smallstepx = 20;
	stepx = 30;

	// Checkboxes and radio buttons section
    gump.AddGroup(1);
    for (var i = 0; i < sortedFeatures.length; i++)
    {
        if (sortedFeatures[i].type != 'combatmode' && sortedFeatures[i].type != 'setup') {
			feature_name = sortedFeatures[i].name;
			feature_status = Shared.GetVar(sortedFeatures[i].name) == 'on' ? 1:0;
			feature_color = Shared.GetVar(sortedFeatures[i].name) == 'on' ? 1426 : 1653;
			feature_command = sortedFeatures[i].command;
			check_serial = i+1;

				if (feature_status == 1)
		        	gump.AddButton(check_serial, x, 10, '0x2C89', '0x2C89', '0x2C89', '0', 1);
		        else 
		        	gump.AddButton(check_serial, x, 10, '0x2C93', '0x2C93', '0x2C93', '0', 1);		        
		        x += smallstepx;
	        	gump.AddText(x, 5, 0, feature_command);
	        x += stepx;
        }

    }
    details_serial = 150;
	gump.AddButton(details_serial, x, 5, '0x26AF', '0x26AF', '0x26AF', '0', '0x26B2', '0x26B2', 0, 1);		        


	if (Orion.GetGlobal('showDetails') == 'true') 
	{
	gump.AddHtmlGump(666, 580, 0, 1200, 300	, '3500', 1,1);
	gump.Select('htmlgump', 666);
	var stepx = 130;
    var stepy = 17;
	var x = 15;
	var y = 15;

		gump.AddText(x, y, '0', '<b>Feature</b>');
		x += 100
		gump.AddText(x, y, '0', 'Command');
		x += 70
		gump.AddText(x, y, '0', 'Type');
		x += 75
		gump.AddText(x, y, '0', 'Status');
		x += 60
		gump.AddText(x, y, '0', 'Full data');
		x =15


    var sortedFeatures = features.sort(GetSortOrder("name")).forEach(function(feature){
		y += stepy
		x = 15
		gump.AddText(x, y, '0', '<small>'+feature.name.substring(0,15)+'</small>');
		x += 100
		gump.AddText(x, y, '0', '<small>'+feature.command+'</small>');
		x += 70
		gump.AddText(x, y, '0', '<small>'+feature.type+'</small>');
		x += 75
		gump.AddText(x, y, Shared.GetVar(feature.name) == 'on' ? 1426 : 1653, Shared.GetVar(feature.name));
		x += 60
		gump.AddText(x, y, '0', '<small>'+JSON.stringify(feature)+'</small>');
		x += stepx

    });
    


	}

	// Reset container for new items to gump
	gump.Select('gump');
	// Commit gump changes and update it in client
	gump.Update();
}


function statusBar_callbacks(unused)
{
	var i = CustomGumpResponse.ReturnCode();

	var showDetails = false;
	if (i == 0 )
	{
		return true;
	}

	if (i < 150)
	{
		i = i-1; // index adjustment
	    var sortedFeatures = features.sort(GetSortOrder("name")).filter(function(feature){
	    	if (!Orion.Contains(feature.type, 'combatmode|setup'))
	    	{
	    		return feature;
	    	}
	    });
				feature_name = sortedFeatures[i].name;
	            feature_status = Shared.GetVar(feature_name);
	
			new_status = feature_status == 'on' ? 'off' : 'on';
			Shared.RemoveVar(feature_name);
			Shared.AddVar(feature_name, new_status);
			Orion.Print(feature_name + ' is now ' + new_status);
	}	
	
  	    if (i == 150 && Orion.GetGlobal('showDetails') != 'true')
  	    {
	  	     Orion.SetGlobal('showDetails', 'true');  	    
  	    }
		else 
		{
		Orion.SetGlobal('showDetails', 'false');
		}



		statusBar(showDetails);

}






function al_buildcreatelists()
{
  	file = Orion.NewFile();
  	file.Open('teste.txt');   	
	items = Orion.FindTypeEx('any', 'any', 'ground', 'item', '10', '').filter(function(item){
		if (!Orion.Contains(item.Name(), 'Brazier|Statue|Earrings|Used|Woven|Chief|Candle|Virtue|Glimmering|Travesty|Badge|Minotaur|Amber|Maggots|Collection|Glob|Bones|Essence|Heart|Rope|Lard|Sweat|Tree|Leaves|Saliva|Abscess|Coil')) return item;
	});
	items
	.forEach(function(item){
    abrname = []
		if (item.Name() != "" ) 
		{
			words = item.Name().replace("'", "").toUpperCase().split(' ');
   		    words.forEach(function(word){
   		    	abrname.push(word.substring(0,3));
   		    });

			abrname = abrname.join('');
            file.WriteLine('//Generic Looter generated by ' + Player.Name() + ': ' + item.Name());
  			file.WriteLine('@createlist '+ '"'+abrname+'N"');
  			file.WriteLine('@clearlist '+ '"'+abrname +'N"');
			file.WriteLine("@pushlist " + '"'+abrname +'N" '+'"'+ item.Name()+'"');
  			file.WriteLine('@createlist '+ '"'+abrname+'G"');
  			file.WriteLine('@clearlist '+ '"'+abrname +'G"');
			file.WriteLine("@pushlist " + '"'+abrname +'G" '+'"'+ item.Graphic()+'"');
  			file.WriteLine('@createlist '+ '"'+abrname+'C"');
  			file.WriteLine('@clearlist '+ '"'+abrname +'C"');
			file.WriteLine("@pushlist " + '"'+abrname +'C" '+'"'+ item.Color()+'"');
        	file.WriteLine('//---------------------------------------------------');			
		}
	});
        	file.WriteLine('//--- MOVE ITEMS ---');
	items.forEach(function(item)
	{
		 abrname = []
			if (item.Name() != "" ) 
			{
				words = item.Name().replace("'", "").toUpperCase().split(' ');
				    words.forEach(function(word){
				    	abrname.push(word.substring(0,3));
				    });
			abrname = abrname.join('');
            file.WriteLine('//Generic Looter generated by ' + Player.Name() + ': ' + item.Name());
	      	file.WriteLine("if @findtype '"+abrname+'G[0]'+"' '"+ abrname+'C[0]' + "' " + "'corpse'" );
	      	file.WriteLine("    moveitem 'found' 'backpack'" );
    		file.WriteLine('    headmsg "Found ' + item.Name() + '"');
	      	file.WriteLine("    pause 800" );
	      	file.WriteLine("endif" );
        	file.WriteLine('//---------------------------------------------------');			
		}
	});
	
	
	file.Close();
}
